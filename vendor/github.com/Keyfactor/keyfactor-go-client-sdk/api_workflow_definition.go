/*
Keyfactor-v1

This reference serves to document REST-based methods to manage and integrate with Keyfactor. In addition, an embedded interface allows for the execution of calls against the current Keyfactor API instance.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keyfactor_command_client_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// WorkflowDefinitionApiService WorkflowDefinitionApi service
type WorkflowDefinitionApiService service

type ApiWorkflowDefinitionConfigureDefinitionStepsRequest struct {
	ctx context.Context
	ApiService *WorkflowDefinitionApiService
	definitionId string
	xKeyfactorRequestedWith *string
	request *[]KeyfactorApiModelsWorkflowsDefinitionStepRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiWorkflowDefinitionConfigureDefinitionStepsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiWorkflowDefinitionConfigureDefinitionStepsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// A collection of {KeyfactorApi.Models.Workflows.DefinitionStepRequest} defining the steps to set on the definition.
func (r ApiWorkflowDefinitionConfigureDefinitionStepsRequest) Request(request []KeyfactorApiModelsWorkflowsDefinitionStepRequest) ApiWorkflowDefinitionConfigureDefinitionStepsRequest {
	r.request = &request
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiWorkflowDefinitionConfigureDefinitionStepsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiWorkflowDefinitionConfigureDefinitionStepsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiWorkflowDefinitionConfigureDefinitionStepsRequest) Execute() (*KeyfactorApiModelsWorkflowsDefinitionResponse, *http.Response, error) {
	return r.ApiService.WorkflowDefinitionConfigureDefinitionStepsExecute(r)
}

/*
WorkflowDefinitionConfigureDefinitionSteps Sets the provided steps on the latest version of the definition.

If the latest version is also the published version, a new version will be created and the steps will be set on that new version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param definitionId The Id of the definition.
 @return ApiWorkflowDefinitionConfigureDefinitionStepsRequest
*/
func (a *WorkflowDefinitionApiService) WorkflowDefinitionConfigureDefinitionSteps(ctx context.Context, definitionId string) ApiWorkflowDefinitionConfigureDefinitionStepsRequest {
	return ApiWorkflowDefinitionConfigureDefinitionStepsRequest{
		ApiService: a,
		ctx: ctx,
		definitionId: definitionId,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsWorkflowsDefinitionResponse
func (a *WorkflowDefinitionApiService) WorkflowDefinitionConfigureDefinitionStepsExecute(r ApiWorkflowDefinitionConfigureDefinitionStepsRequest) (*KeyfactorApiModelsWorkflowsDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsWorkflowsDefinitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowDefinitionApiService.WorkflowDefinitionConfigureDefinitionSteps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Workflow/Definitions/{definitionId}/Steps"
	localVarPath = strings.Replace(localVarPath, "{"+"definitionId"+"}", url.PathEscape(parameterValueToString(r.definitionId, "definitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkflowDefinitionCreateNewDefinitionRequest struct {
	ctx context.Context
	ApiService *WorkflowDefinitionApiService
	xKeyfactorRequestedWith *string
	request *KeyfactorApiModelsWorkflowsDefinitionCreateRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiWorkflowDefinitionCreateNewDefinitionRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiWorkflowDefinitionCreateNewDefinitionRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// A {KeyfactorApi.Models.Workflows.DefinitionCreateRequest} with the display name, description, key and type of the definition.
func (r ApiWorkflowDefinitionCreateNewDefinitionRequest) Request(request KeyfactorApiModelsWorkflowsDefinitionCreateRequest) ApiWorkflowDefinitionCreateNewDefinitionRequest {
	r.request = &request
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiWorkflowDefinitionCreateNewDefinitionRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiWorkflowDefinitionCreateNewDefinitionRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiWorkflowDefinitionCreateNewDefinitionRequest) Execute() (*KeyfactorApiModelsWorkflowsDefinitionResponse, *http.Response, error) {
	return r.ApiService.WorkflowDefinitionCreateNewDefinitionExecute(r)
}

/*
WorkflowDefinitionCreateNewDefinition Creates a new base definition without any steps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWorkflowDefinitionCreateNewDefinitionRequest
*/
func (a *WorkflowDefinitionApiService) WorkflowDefinitionCreateNewDefinition(ctx context.Context) ApiWorkflowDefinitionCreateNewDefinitionRequest {
	return ApiWorkflowDefinitionCreateNewDefinitionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsWorkflowsDefinitionResponse
func (a *WorkflowDefinitionApiService) WorkflowDefinitionCreateNewDefinitionExecute(r ApiWorkflowDefinitionCreateNewDefinitionRequest) (*KeyfactorApiModelsWorkflowsDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsWorkflowsDefinitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowDefinitionApiService.WorkflowDefinitionCreateNewDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Workflow/Definitions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkflowDefinitionDeleteRequest struct {
	ctx context.Context
	ApiService *WorkflowDefinitionApiService
	definitionId string
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiWorkflowDefinitionDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiWorkflowDefinitionDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiWorkflowDefinitionDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiWorkflowDefinitionDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiWorkflowDefinitionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.WorkflowDefinitionDeleteExecute(r)
}

/*
WorkflowDefinitionDelete Deletes the definition matching the given Id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param definitionId The Workflow Definition Id.
 @return ApiWorkflowDefinitionDeleteRequest
*/
func (a *WorkflowDefinitionApiService) WorkflowDefinitionDelete(ctx context.Context, definitionId string) ApiWorkflowDefinitionDeleteRequest {
	return ApiWorkflowDefinitionDeleteRequest{
		ApiService: a,
		ctx: ctx,
		definitionId: definitionId,
	}
}

// Execute executes the request
func (a *WorkflowDefinitionApiService) WorkflowDefinitionDeleteExecute(r ApiWorkflowDefinitionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowDefinitionApiService.WorkflowDefinitionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Workflow/Definitions/{definitionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"definitionId"+"}", url.PathEscape(parameterValueToString(r.definitionId, "definitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWorkflowDefinitionGetRequest struct {
	ctx context.Context
	ApiService *WorkflowDefinitionApiService
	definitionId string
	xKeyfactorRequestedWith *string
	definitionVersion *int32
	exportable *bool
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiWorkflowDefinitionGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiWorkflowDefinitionGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The version to retrieve. If this value is not specified, the latest version will be returned.
func (r ApiWorkflowDefinitionGetRequest) DefinitionVersion(definitionVersion int32) ApiWorkflowDefinitionGetRequest {
	r.definitionVersion = &definitionVersion
	return r
}

// Indicates if the response should be cleansed of role ids for export.
func (r ApiWorkflowDefinitionGetRequest) Exportable(exportable bool) ApiWorkflowDefinitionGetRequest {
	r.exportable = &exportable
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiWorkflowDefinitionGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiWorkflowDefinitionGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiWorkflowDefinitionGetRequest) Execute() (*KeyfactorApiModelsWorkflowsDefinitionResponse, *http.Response, error) {
	return r.ApiService.WorkflowDefinitionGetExecute(r)
}

/*
WorkflowDefinitionGet Gets a workflow definition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param definitionId The Id of the definition to retrieve.
 @return ApiWorkflowDefinitionGetRequest
*/
func (a *WorkflowDefinitionApiService) WorkflowDefinitionGet(ctx context.Context, definitionId string) ApiWorkflowDefinitionGetRequest {
	return ApiWorkflowDefinitionGetRequest{
		ApiService: a,
		ctx: ctx,
		definitionId: definitionId,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsWorkflowsDefinitionResponse
func (a *WorkflowDefinitionApiService) WorkflowDefinitionGetExecute(r ApiWorkflowDefinitionGetRequest) (*KeyfactorApiModelsWorkflowsDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsWorkflowsDefinitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowDefinitionApiService.WorkflowDefinitionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Workflow/Definitions/{definitionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"definitionId"+"}", url.PathEscape(parameterValueToString(r.definitionId, "definitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.definitionVersion != nil {
		parameterAddToQuery(localVarQueryParams, "definitionVersion", r.definitionVersion, "")
	}
	if r.exportable != nil {
		parameterAddToQuery(localVarQueryParams, "exportable", r.exportable, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkflowDefinitionGetStepSchemaRequest struct {
	ctx context.Context
	ApiService *WorkflowDefinitionApiService
	extensionName string
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiWorkflowDefinitionGetStepSchemaRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiWorkflowDefinitionGetStepSchemaRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiWorkflowDefinitionGetStepSchemaRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiWorkflowDefinitionGetStepSchemaRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiWorkflowDefinitionGetStepSchemaRequest) Execute() (*KeyfactorApiModelsWorkflowsAvailableStepResponse, *http.Response, error) {
	return r.ApiService.WorkflowDefinitionGetStepSchemaExecute(r)
}

/*
WorkflowDefinitionGetStepSchema Gets the schema of a given step with the specified extension name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param extensionName The extension name of a specific step in the step schema.
 @return ApiWorkflowDefinitionGetStepSchemaRequest
*/
func (a *WorkflowDefinitionApiService) WorkflowDefinitionGetStepSchema(ctx context.Context, extensionName string) ApiWorkflowDefinitionGetStepSchemaRequest {
	return ApiWorkflowDefinitionGetStepSchemaRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsWorkflowsAvailableStepResponse
func (a *WorkflowDefinitionApiService) WorkflowDefinitionGetStepSchemaExecute(r ApiWorkflowDefinitionGetStepSchemaRequest) (*KeyfactorApiModelsWorkflowsAvailableStepResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsWorkflowsAvailableStepResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowDefinitionApiService.WorkflowDefinitionGetStepSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Workflow/Definitions/Steps/{extensionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", url.PathEscape(parameterValueToString(r.extensionName, "extensionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkflowDefinitionPublishDefinitionRequest struct {
	ctx context.Context
	ApiService *WorkflowDefinitionApiService
	definitionId string
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiWorkflowDefinitionPublishDefinitionRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiWorkflowDefinitionPublishDefinitionRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiWorkflowDefinitionPublishDefinitionRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiWorkflowDefinitionPublishDefinitionRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiWorkflowDefinitionPublishDefinitionRequest) Execute() (*KeyfactorApiModelsWorkflowsDefinitionResponse, *http.Response, error) {
	return r.ApiService.WorkflowDefinitionPublishDefinitionExecute(r)
}

/*
WorkflowDefinitionPublishDefinition Makes the most recent version of a Workflow Definition the published version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param definitionId The Workflow Definition Id.
 @return ApiWorkflowDefinitionPublishDefinitionRequest
*/
func (a *WorkflowDefinitionApiService) WorkflowDefinitionPublishDefinition(ctx context.Context, definitionId string) ApiWorkflowDefinitionPublishDefinitionRequest {
	return ApiWorkflowDefinitionPublishDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		definitionId: definitionId,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsWorkflowsDefinitionResponse
func (a *WorkflowDefinitionApiService) WorkflowDefinitionPublishDefinitionExecute(r ApiWorkflowDefinitionPublishDefinitionRequest) (*KeyfactorApiModelsWorkflowsDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsWorkflowsDefinitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowDefinitionApiService.WorkflowDefinitionPublishDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Workflow/Definitions/{definitionId}/Publish"
	localVarPath = strings.Replace(localVarPath, "{"+"definitionId"+"}", url.PathEscape(parameterValueToString(r.definitionId, "definitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkflowDefinitionQueryRequest struct {
	ctx context.Context
	ApiService *WorkflowDefinitionApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
	queryQueryString *string
	queryPageReturned *int32
	queryReturnLimit *int32
	querySortField *string
	querySortAscending *int32
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiWorkflowDefinitionQueryRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiWorkflowDefinitionQueryRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiWorkflowDefinitionQueryRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiWorkflowDefinitionQueryRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Contents of the query (ex: field1 -eq value1 AND field2 -gt value2)
func (r ApiWorkflowDefinitionQueryRequest) QueryQueryString(queryQueryString string) ApiWorkflowDefinitionQueryRequest {
	r.queryQueryString = &queryQueryString
	return r
}

// The current page within the result set to be returned
func (r ApiWorkflowDefinitionQueryRequest) QueryPageReturned(queryPageReturned int32) ApiWorkflowDefinitionQueryRequest {
	r.queryPageReturned = &queryPageReturned
	return r
}

// Maximum number of records to be returned in a single call
func (r ApiWorkflowDefinitionQueryRequest) QueryReturnLimit(queryReturnLimit int32) ApiWorkflowDefinitionQueryRequest {
	r.queryReturnLimit = &queryReturnLimit
	return r
}

// Field by which the results should be sorted (view results via Management Portal for sortable columns)
func (r ApiWorkflowDefinitionQueryRequest) QuerySortField(querySortField string) ApiWorkflowDefinitionQueryRequest {
	r.querySortField = &querySortField
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiWorkflowDefinitionQueryRequest) QuerySortAscending(querySortAscending int32) ApiWorkflowDefinitionQueryRequest {
	r.querySortAscending = &querySortAscending
	return r
}

func (r ApiWorkflowDefinitionQueryRequest) Execute() ([]KeyfactorApiModelsWorkflowsDefinitionQueryResponse, *http.Response, error) {
	return r.ApiService.WorkflowDefinitionQueryExecute(r)
}

/*
WorkflowDefinitionQuery Gets the Definitions matching the query specifications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWorkflowDefinitionQueryRequest
*/
func (a *WorkflowDefinitionApiService) WorkflowDefinitionQuery(ctx context.Context) ApiWorkflowDefinitionQueryRequest {
	return ApiWorkflowDefinitionQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsWorkflowsDefinitionQueryResponse
func (a *WorkflowDefinitionApiService) WorkflowDefinitionQueryExecute(r ApiWorkflowDefinitionQueryRequest) ([]KeyfactorApiModelsWorkflowsDefinitionQueryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsWorkflowsDefinitionQueryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowDefinitionApiService.WorkflowDefinitionQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Workflow/Definitions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.queryQueryString != nil {
		parameterAddToQuery(localVarQueryParams, "query.queryString", r.queryQueryString, "")
	}
	if r.queryPageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "query.pageReturned", r.queryPageReturned, "")
	}
	if r.queryReturnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "query.returnLimit", r.queryReturnLimit, "")
	}
	if r.querySortField != nil {
		parameterAddToQuery(localVarQueryParams, "query.sortField", r.querySortField, "")
	}
	if r.querySortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "query.sortAscending", r.querySortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkflowDefinitionQueryAvailableStepsRequest struct {
	ctx context.Context
	ApiService *WorkflowDefinitionApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
	queryQueryString *string
	queryPageReturned *int32
	queryReturnLimit *int32
	querySortField *string
	querySortAscending *int32
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiWorkflowDefinitionQueryAvailableStepsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiWorkflowDefinitionQueryAvailableStepsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiWorkflowDefinitionQueryAvailableStepsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiWorkflowDefinitionQueryAvailableStepsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Contents of the query (ex: field1 -eq value1 AND field2 -gt value2)
func (r ApiWorkflowDefinitionQueryAvailableStepsRequest) QueryQueryString(queryQueryString string) ApiWorkflowDefinitionQueryAvailableStepsRequest {
	r.queryQueryString = &queryQueryString
	return r
}

// The current page within the result set to be returned
func (r ApiWorkflowDefinitionQueryAvailableStepsRequest) QueryPageReturned(queryPageReturned int32) ApiWorkflowDefinitionQueryAvailableStepsRequest {
	r.queryPageReturned = &queryPageReturned
	return r
}

// Maximum number of records to be returned in a single call
func (r ApiWorkflowDefinitionQueryAvailableStepsRequest) QueryReturnLimit(queryReturnLimit int32) ApiWorkflowDefinitionQueryAvailableStepsRequest {
	r.queryReturnLimit = &queryReturnLimit
	return r
}

// Field by which the results should be sorted (view results via Management Portal for sortable columns)
func (r ApiWorkflowDefinitionQueryAvailableStepsRequest) QuerySortField(querySortField string) ApiWorkflowDefinitionQueryAvailableStepsRequest {
	r.querySortField = &querySortField
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiWorkflowDefinitionQueryAvailableStepsRequest) QuerySortAscending(querySortAscending int32) ApiWorkflowDefinitionQueryAvailableStepsRequest {
	r.querySortAscending = &querySortAscending
	return r
}

func (r ApiWorkflowDefinitionQueryAvailableStepsRequest) Execute() ([]KeyfactorApiModelsWorkflowsAvailableStepQueryResponse, *http.Response, error) {
	return r.ApiService.WorkflowDefinitionQueryAvailableStepsExecute(r)
}

/*
WorkflowDefinitionQueryAvailableSteps Gets the result set of available steps for a given query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWorkflowDefinitionQueryAvailableStepsRequest
*/
func (a *WorkflowDefinitionApiService) WorkflowDefinitionQueryAvailableSteps(ctx context.Context) ApiWorkflowDefinitionQueryAvailableStepsRequest {
	return ApiWorkflowDefinitionQueryAvailableStepsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsWorkflowsAvailableStepQueryResponse
func (a *WorkflowDefinitionApiService) WorkflowDefinitionQueryAvailableStepsExecute(r ApiWorkflowDefinitionQueryAvailableStepsRequest) ([]KeyfactorApiModelsWorkflowsAvailableStepQueryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsWorkflowsAvailableStepQueryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowDefinitionApiService.WorkflowDefinitionQueryAvailableSteps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Workflow/Definitions/Steps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.queryQueryString != nil {
		parameterAddToQuery(localVarQueryParams, "query.queryString", r.queryQueryString, "")
	}
	if r.queryPageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "query.pageReturned", r.queryPageReturned, "")
	}
	if r.queryReturnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "query.returnLimit", r.queryReturnLimit, "")
	}
	if r.querySortField != nil {
		parameterAddToQuery(localVarQueryParams, "query.sortField", r.querySortField, "")
	}
	if r.querySortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "query.sortAscending", r.querySortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkflowDefinitionQueryWorkflowTypesRequest struct {
	ctx context.Context
	ApiService *WorkflowDefinitionApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
	queryQueryString *string
	queryPageReturned *int32
	queryReturnLimit *int32
	querySortField *string
	querySortAscending *int32
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiWorkflowDefinitionQueryWorkflowTypesRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiWorkflowDefinitionQueryWorkflowTypesRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiWorkflowDefinitionQueryWorkflowTypesRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiWorkflowDefinitionQueryWorkflowTypesRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Contents of the query (ex: field1 -eq value1 AND field2 -gt value2)
func (r ApiWorkflowDefinitionQueryWorkflowTypesRequest) QueryQueryString(queryQueryString string) ApiWorkflowDefinitionQueryWorkflowTypesRequest {
	r.queryQueryString = &queryQueryString
	return r
}

// The current page within the result set to be returned
func (r ApiWorkflowDefinitionQueryWorkflowTypesRequest) QueryPageReturned(queryPageReturned int32) ApiWorkflowDefinitionQueryWorkflowTypesRequest {
	r.queryPageReturned = &queryPageReturned
	return r
}

// Maximum number of records to be returned in a single call
func (r ApiWorkflowDefinitionQueryWorkflowTypesRequest) QueryReturnLimit(queryReturnLimit int32) ApiWorkflowDefinitionQueryWorkflowTypesRequest {
	r.queryReturnLimit = &queryReturnLimit
	return r
}

// Field by which the results should be sorted (view results via Management Portal for sortable columns)
func (r ApiWorkflowDefinitionQueryWorkflowTypesRequest) QuerySortField(querySortField string) ApiWorkflowDefinitionQueryWorkflowTypesRequest {
	r.querySortField = &querySortField
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiWorkflowDefinitionQueryWorkflowTypesRequest) QuerySortAscending(querySortAscending int32) ApiWorkflowDefinitionQueryWorkflowTypesRequest {
	r.querySortAscending = &querySortAscending
	return r
}

func (r ApiWorkflowDefinitionQueryWorkflowTypesRequest) Execute() ([]KeyfactorApiModelsWorkflowsWorkflowTypeQueryResponse, *http.Response, error) {
	return r.ApiService.WorkflowDefinitionQueryWorkflowTypesExecute(r)
}

/*
WorkflowDefinitionQueryWorkflowTypes Performs a query against the workflow types in the system.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWorkflowDefinitionQueryWorkflowTypesRequest
*/
func (a *WorkflowDefinitionApiService) WorkflowDefinitionQueryWorkflowTypes(ctx context.Context) ApiWorkflowDefinitionQueryWorkflowTypesRequest {
	return ApiWorkflowDefinitionQueryWorkflowTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsWorkflowsWorkflowTypeQueryResponse
func (a *WorkflowDefinitionApiService) WorkflowDefinitionQueryWorkflowTypesExecute(r ApiWorkflowDefinitionQueryWorkflowTypesRequest) ([]KeyfactorApiModelsWorkflowsWorkflowTypeQueryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsWorkflowsWorkflowTypeQueryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowDefinitionApiService.WorkflowDefinitionQueryWorkflowTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Workflow/Definitions/Types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.queryQueryString != nil {
		parameterAddToQuery(localVarQueryParams, "query.queryString", r.queryQueryString, "")
	}
	if r.queryPageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "query.pageReturned", r.queryPageReturned, "")
	}
	if r.queryReturnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "query.returnLimit", r.queryReturnLimit, "")
	}
	if r.querySortField != nil {
		parameterAddToQuery(localVarQueryParams, "query.sortField", r.querySortField, "")
	}
	if r.querySortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "query.sortAscending", r.querySortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkflowDefinitionUpdateExistingDefinitionRequest struct {
	ctx context.Context
	ApiService *WorkflowDefinitionApiService
	definitionId string
	xKeyfactorRequestedWith *string
	request *KeyfactorApiModelsWorkflowsDefinitionUpdateRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiWorkflowDefinitionUpdateExistingDefinitionRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiWorkflowDefinitionUpdateExistingDefinitionRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The {KeyfactorApi.Models.Workflows.DefinitionUpdateRequest} holding the updated DispalyName and Description.
func (r ApiWorkflowDefinitionUpdateExistingDefinitionRequest) Request(request KeyfactorApiModelsWorkflowsDefinitionUpdateRequest) ApiWorkflowDefinitionUpdateExistingDefinitionRequest {
	r.request = &request
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiWorkflowDefinitionUpdateExistingDefinitionRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiWorkflowDefinitionUpdateExistingDefinitionRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiWorkflowDefinitionUpdateExistingDefinitionRequest) Execute() (*KeyfactorApiModelsWorkflowsDefinitionResponse, *http.Response, error) {
	return r.ApiService.WorkflowDefinitionUpdateExistingDefinitionExecute(r)
}

/*
WorkflowDefinitionUpdateExistingDefinition Updates the existing definition's DisplayName and Description.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param definitionId The Id of the definition to update.
 @return ApiWorkflowDefinitionUpdateExistingDefinitionRequest
*/
func (a *WorkflowDefinitionApiService) WorkflowDefinitionUpdateExistingDefinition(ctx context.Context, definitionId string) ApiWorkflowDefinitionUpdateExistingDefinitionRequest {
	return ApiWorkflowDefinitionUpdateExistingDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		definitionId: definitionId,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsWorkflowsDefinitionResponse
func (a *WorkflowDefinitionApiService) WorkflowDefinitionUpdateExistingDefinitionExecute(r ApiWorkflowDefinitionUpdateExistingDefinitionRequest) (*KeyfactorApiModelsWorkflowsDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsWorkflowsDefinitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowDefinitionApiService.WorkflowDefinitionUpdateExistingDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Workflow/Definitions/{definitionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"definitionId"+"}", url.PathEscape(parameterValueToString(r.definitionId, "definitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
