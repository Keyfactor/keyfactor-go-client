/*
Keyfactor-v1

This reference serves to document REST-based methods to manage and integrate with Keyfactor. In addition, an embedded interface allows for the execution of calls against the current Keyfactor API instance.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keyfactor_command_client_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// KeyRotationAlertApiService KeyRotationAlertApi service
type KeyRotationAlertApiService service

type ApiKeyRotationAlertAddKeyRotationAlertRequest struct {
	ctx context.Context
	ApiService *KeyRotationAlertApiService
	xKeyfactorRequestedWith *string
	req *KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertCreationRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiKeyRotationAlertAddKeyRotationAlertRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiKeyRotationAlertAddKeyRotationAlertRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Information for the new alert
func (r ApiKeyRotationAlertAddKeyRotationAlertRequest) Req(req KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertCreationRequest) ApiKeyRotationAlertAddKeyRotationAlertRequest {
	r.req = &req
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiKeyRotationAlertAddKeyRotationAlertRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiKeyRotationAlertAddKeyRotationAlertRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiKeyRotationAlertAddKeyRotationAlertRequest) Execute() (*KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	return r.ApiService.KeyRotationAlertAddKeyRotationAlertExecute(r)
}

/*
KeyRotationAlertAddKeyRotationAlert Add a key rotation alert

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKeyRotationAlertAddKeyRotationAlertRequest
*/
func (a *KeyRotationAlertApiService) KeyRotationAlertAddKeyRotationAlert(ctx context.Context) ApiKeyRotationAlertAddKeyRotationAlertRequest {
	return ApiKeyRotationAlertAddKeyRotationAlertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
func (a *KeyRotationAlertApiService) KeyRotationAlertAddKeyRotationAlertExecute(r ApiKeyRotationAlertAddKeyRotationAlertRequest) (*KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KeyRotationAlertApiService.KeyRotationAlertAddKeyRotationAlert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Alerts/KeyRotation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.req == nil {
		return localVarReturnValue, nil, reportError("req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.req
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKeyRotationAlertDeleteKeyRotationAlertRequest struct {
	ctx context.Context
	ApiService *KeyRotationAlertApiService
	id int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiKeyRotationAlertDeleteKeyRotationAlertRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiKeyRotationAlertDeleteKeyRotationAlertRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiKeyRotationAlertDeleteKeyRotationAlertRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiKeyRotationAlertDeleteKeyRotationAlertRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiKeyRotationAlertDeleteKeyRotationAlertRequest) Execute() (*http.Response, error) {
	return r.ApiService.KeyRotationAlertDeleteKeyRotationAlertExecute(r)
}

/*
KeyRotationAlertDeleteKeyRotationAlert Delete a key rotation alert

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Id for the key rotation alert
 @return ApiKeyRotationAlertDeleteKeyRotationAlertRequest
*/
func (a *KeyRotationAlertApiService) KeyRotationAlertDeleteKeyRotationAlert(ctx context.Context, id int32) ApiKeyRotationAlertDeleteKeyRotationAlertRequest {
	return ApiKeyRotationAlertDeleteKeyRotationAlertRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *KeyRotationAlertApiService) KeyRotationAlertDeleteKeyRotationAlertExecute(r ApiKeyRotationAlertDeleteKeyRotationAlertRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KeyRotationAlertApiService.KeyRotationAlertDeleteKeyRotationAlert")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Alerts/KeyRotation/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiKeyRotationAlertEditKeyRotationAlertRequest struct {
	ctx context.Context
	ApiService *KeyRotationAlertApiService
	xKeyfactorRequestedWith *string
	req *KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertUpdateRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiKeyRotationAlertEditKeyRotationAlertRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiKeyRotationAlertEditKeyRotationAlertRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Information for the key rotation alert
func (r ApiKeyRotationAlertEditKeyRotationAlertRequest) Req(req KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertUpdateRequest) ApiKeyRotationAlertEditKeyRotationAlertRequest {
	r.req = &req
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiKeyRotationAlertEditKeyRotationAlertRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiKeyRotationAlertEditKeyRotationAlertRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiKeyRotationAlertEditKeyRotationAlertRequest) Execute() (*KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	return r.ApiService.KeyRotationAlertEditKeyRotationAlertExecute(r)
}

/*
KeyRotationAlertEditKeyRotationAlert Edit a key rotation alert

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKeyRotationAlertEditKeyRotationAlertRequest
*/
func (a *KeyRotationAlertApiService) KeyRotationAlertEditKeyRotationAlert(ctx context.Context) ApiKeyRotationAlertEditKeyRotationAlertRequest {
	return ApiKeyRotationAlertEditKeyRotationAlertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
func (a *KeyRotationAlertApiService) KeyRotationAlertEditKeyRotationAlertExecute(r ApiKeyRotationAlertEditKeyRotationAlertRequest) (*KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KeyRotationAlertApiService.KeyRotationAlertEditKeyRotationAlert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Alerts/KeyRotation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.req == nil {
		return localVarReturnValue, nil, reportError("req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.req
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKeyRotationAlertEditScheduleRequest struct {
	ctx context.Context
	ApiService *KeyRotationAlertApiService
	xKeyfactorRequestedWith *string
	newSchedule *KeyfactorApiModelsAlertsAlertScheduleAlertScheduleRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiKeyRotationAlertEditScheduleRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiKeyRotationAlertEditScheduleRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

func (r ApiKeyRotationAlertEditScheduleRequest) NewSchedule(newSchedule KeyfactorApiModelsAlertsAlertScheduleAlertScheduleRequest) ApiKeyRotationAlertEditScheduleRequest {
	r.newSchedule = &newSchedule
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiKeyRotationAlertEditScheduleRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiKeyRotationAlertEditScheduleRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiKeyRotationAlertEditScheduleRequest) Execute() (*KeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse, *http.Response, error) {
	return r.ApiService.KeyRotationAlertEditScheduleExecute(r)
}

/*
KeyRotationAlertEditSchedule Edit schedule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKeyRotationAlertEditScheduleRequest
*/
func (a *KeyRotationAlertApiService) KeyRotationAlertEditSchedule(ctx context.Context) ApiKeyRotationAlertEditScheduleRequest {
	return ApiKeyRotationAlertEditScheduleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse
func (a *KeyRotationAlertApiService) KeyRotationAlertEditScheduleExecute(r ApiKeyRotationAlertEditScheduleRequest) (*KeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KeyRotationAlertApiService.KeyRotationAlertEditSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Alerts/KeyRotation/Schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.newSchedule == nil {
		return localVarReturnValue, nil, reportError("newSchedule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.newSchedule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKeyRotationAlertGetKeyRotationAlertRequest struct {
	ctx context.Context
	ApiService *KeyRotationAlertApiService
	id int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiKeyRotationAlertGetKeyRotationAlertRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiKeyRotationAlertGetKeyRotationAlertRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiKeyRotationAlertGetKeyRotationAlertRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiKeyRotationAlertGetKeyRotationAlertRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiKeyRotationAlertGetKeyRotationAlertRequest) Execute() (*KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	return r.ApiService.KeyRotationAlertGetKeyRotationAlertExecute(r)
}

/*
KeyRotationAlertGetKeyRotationAlert Get a key rotation alert

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Id for the key rotation alert to get
 @return ApiKeyRotationAlertGetKeyRotationAlertRequest
*/
func (a *KeyRotationAlertApiService) KeyRotationAlertGetKeyRotationAlert(ctx context.Context, id int32) ApiKeyRotationAlertGetKeyRotationAlertRequest {
	return ApiKeyRotationAlertGetKeyRotationAlertRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
func (a *KeyRotationAlertApiService) KeyRotationAlertGetKeyRotationAlertExecute(r ApiKeyRotationAlertGetKeyRotationAlertRequest) (*KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KeyRotationAlertApiService.KeyRotationAlertGetKeyRotationAlert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Alerts/KeyRotation/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKeyRotationAlertGetKeyRotationAlertsRequest struct {
	ctx context.Context
	ApiService *KeyRotationAlertApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
	pagedQueryQueryString *string
	pagedQueryPageReturned *int32
	pagedQueryReturnLimit *int32
	pagedQuerySortField *string
	pagedQuerySortAscending *int32
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiKeyRotationAlertGetKeyRotationAlertsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiKeyRotationAlertGetKeyRotationAlertsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiKeyRotationAlertGetKeyRotationAlertsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiKeyRotationAlertGetKeyRotationAlertsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Contents of the query (ex: field1 -eq value1 AND field2 -gt value2)
func (r ApiKeyRotationAlertGetKeyRotationAlertsRequest) PagedQueryQueryString(pagedQueryQueryString string) ApiKeyRotationAlertGetKeyRotationAlertsRequest {
	r.pagedQueryQueryString = &pagedQueryQueryString
	return r
}

// The current page within the result set to be returned
func (r ApiKeyRotationAlertGetKeyRotationAlertsRequest) PagedQueryPageReturned(pagedQueryPageReturned int32) ApiKeyRotationAlertGetKeyRotationAlertsRequest {
	r.pagedQueryPageReturned = &pagedQueryPageReturned
	return r
}

// Maximum number of records to be returned in a single call
func (r ApiKeyRotationAlertGetKeyRotationAlertsRequest) PagedQueryReturnLimit(pagedQueryReturnLimit int32) ApiKeyRotationAlertGetKeyRotationAlertsRequest {
	r.pagedQueryReturnLimit = &pagedQueryReturnLimit
	return r
}

// Field by which the results should be sorted (view results via Management Portal for sortable columns)
func (r ApiKeyRotationAlertGetKeyRotationAlertsRequest) PagedQuerySortField(pagedQuerySortField string) ApiKeyRotationAlertGetKeyRotationAlertsRequest {
	r.pagedQuerySortField = &pagedQuerySortField
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiKeyRotationAlertGetKeyRotationAlertsRequest) PagedQuerySortAscending(pagedQuerySortAscending int32) ApiKeyRotationAlertGetKeyRotationAlertsRequest {
	r.pagedQuerySortAscending = &pagedQuerySortAscending
	return r
}

func (r ApiKeyRotationAlertGetKeyRotationAlertsRequest) Execute() ([]KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	return r.ApiService.KeyRotationAlertGetKeyRotationAlertsExecute(r)
}

/*
KeyRotationAlertGetKeyRotationAlerts Gets all key rotation alerts according to the provided filter and output parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKeyRotationAlertGetKeyRotationAlertsRequest
*/
func (a *KeyRotationAlertApiService) KeyRotationAlertGetKeyRotationAlerts(ctx context.Context) ApiKeyRotationAlertGetKeyRotationAlertsRequest {
	return ApiKeyRotationAlertGetKeyRotationAlertsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
func (a *KeyRotationAlertApiService) KeyRotationAlertGetKeyRotationAlertsExecute(r ApiKeyRotationAlertGetKeyRotationAlertsRequest) ([]KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KeyRotationAlertApiService.KeyRotationAlertGetKeyRotationAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Alerts/KeyRotation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.pagedQueryQueryString != nil {
		parameterAddToQuery(localVarQueryParams, "pagedQuery.queryString", r.pagedQueryQueryString, "")
	}
	if r.pagedQueryPageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "pagedQuery.pageReturned", r.pagedQueryPageReturned, "")
	}
	if r.pagedQueryReturnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "pagedQuery.returnLimit", r.pagedQueryReturnLimit, "")
	}
	if r.pagedQuerySortField != nil {
		parameterAddToQuery(localVarQueryParams, "pagedQuery.sortField", r.pagedQuerySortField, "")
	}
	if r.pagedQuerySortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "pagedQuery.sortAscending", r.pagedQuerySortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKeyRotationAlertGetScheduleRequest struct {
	ctx context.Context
	ApiService *KeyRotationAlertApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiKeyRotationAlertGetScheduleRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiKeyRotationAlertGetScheduleRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiKeyRotationAlertGetScheduleRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiKeyRotationAlertGetScheduleRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiKeyRotationAlertGetScheduleRequest) Execute() (*KeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse, *http.Response, error) {
	return r.ApiService.KeyRotationAlertGetScheduleExecute(r)
}

/*
KeyRotationAlertGetSchedule Get the schedule for key rotation alerts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKeyRotationAlertGetScheduleRequest
*/
func (a *KeyRotationAlertApiService) KeyRotationAlertGetSchedule(ctx context.Context) ApiKeyRotationAlertGetScheduleRequest {
	return ApiKeyRotationAlertGetScheduleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse
func (a *KeyRotationAlertApiService) KeyRotationAlertGetScheduleExecute(r ApiKeyRotationAlertGetScheduleRequest) (*KeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KeyRotationAlertApiService.KeyRotationAlertGetSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Alerts/KeyRotation/Schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKeyRotationAlertTestAllKeyRotationAlertRequest struct {
	ctx context.Context
	ApiService *KeyRotationAlertApiService
	xKeyfactorRequestedWith *string
	keyRotationAlertTestRequest *KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestAllRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiKeyRotationAlertTestAllKeyRotationAlertRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiKeyRotationAlertTestAllKeyRotationAlertRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Information about the key rotation alert test
func (r ApiKeyRotationAlertTestAllKeyRotationAlertRequest) KeyRotationAlertTestRequest(keyRotationAlertTestRequest KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestAllRequest) ApiKeyRotationAlertTestAllKeyRotationAlertRequest {
	r.keyRotationAlertTestRequest = &keyRotationAlertTestRequest
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiKeyRotationAlertTestAllKeyRotationAlertRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiKeyRotationAlertTestAllKeyRotationAlertRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiKeyRotationAlertTestAllKeyRotationAlertRequest) Execute() (*KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse, *http.Response, error) {
	return r.ApiService.KeyRotationAlertTestAllKeyRotationAlertExecute(r)
}

/*
KeyRotationAlertTestAllKeyRotationAlert Test All Alerts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKeyRotationAlertTestAllKeyRotationAlertRequest
*/
func (a *KeyRotationAlertApiService) KeyRotationAlertTestAllKeyRotationAlert(ctx context.Context) ApiKeyRotationAlertTestAllKeyRotationAlertRequest {
	return ApiKeyRotationAlertTestAllKeyRotationAlertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse
func (a *KeyRotationAlertApiService) KeyRotationAlertTestAllKeyRotationAlertExecute(r ApiKeyRotationAlertTestAllKeyRotationAlertRequest) (*KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KeyRotationAlertApiService.KeyRotationAlertTestAllKeyRotationAlert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Alerts/KeyRotation/TestAll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.keyRotationAlertTestRequest == nil {
		return localVarReturnValue, nil, reportError("keyRotationAlertTestRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyRotationAlertTestRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiKeyRotationAlertTestKeyRotationAlertRequest struct {
	ctx context.Context
	ApiService *KeyRotationAlertApiService
	xKeyfactorRequestedWith *string
	keyRotationAlertTestRequest *KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiKeyRotationAlertTestKeyRotationAlertRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiKeyRotationAlertTestKeyRotationAlertRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Parameters used to test the alert
func (r ApiKeyRotationAlertTestKeyRotationAlertRequest) KeyRotationAlertTestRequest(keyRotationAlertTestRequest KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestRequest) ApiKeyRotationAlertTestKeyRotationAlertRequest {
	r.keyRotationAlertTestRequest = &keyRotationAlertTestRequest
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiKeyRotationAlertTestKeyRotationAlertRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiKeyRotationAlertTestKeyRotationAlertRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiKeyRotationAlertTestKeyRotationAlertRequest) Execute() (*KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse, *http.Response, error) {
	return r.ApiService.KeyRotationAlertTestKeyRotationAlertExecute(r)
}

/*
KeyRotationAlertTestKeyRotationAlert Test An Alert

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKeyRotationAlertTestKeyRotationAlertRequest
*/
func (a *KeyRotationAlertApiService) KeyRotationAlertTestKeyRotationAlert(ctx context.Context) ApiKeyRotationAlertTestKeyRotationAlertRequest {
	return ApiKeyRotationAlertTestKeyRotationAlertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse
func (a *KeyRotationAlertApiService) KeyRotationAlertTestKeyRotationAlertExecute(r ApiKeyRotationAlertTestKeyRotationAlertRequest) (*KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KeyRotationAlertApiService.KeyRotationAlertTestKeyRotationAlert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Alerts/KeyRotation/Test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.keyRotationAlertTestRequest == nil {
		return localVarReturnValue, nil, reportError("keyRotationAlertTestRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyRotationAlertTestRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
