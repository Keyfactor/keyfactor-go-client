/*
Keyfactor-v1

This reference serves to document REST-based methods to manage and integrate with Keyfactor. In addition, an embedded interface allows for the execution of calls against the current Keyfactor API instance.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keyfactor_command_client_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// EnrollmentApiService EnrollmentApi service
type EnrollmentApiService service

type ApiEnrollmentAddToExistingCertStoresRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	xKeyfactorRequestedWith *string
	request *ModelsEnrollmentExistingEnrollmentManagementRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentAddToExistingCertStoresRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentAddToExistingCertStoresRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The request to create the management jobs, which includes the request Id of the new pfx and the Id of the existing certificate
func (r ApiEnrollmentAddToExistingCertStoresRequest) Request(request ModelsEnrollmentExistingEnrollmentManagementRequest) ApiEnrollmentAddToExistingCertStoresRequest {
	r.request = &request
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentAddToExistingCertStoresRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentAddToExistingCertStoresRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentAddToExistingCertStoresRequest) Execute() (*KeyfactorAPIModelsEnrollmentEnrollmentManagementResponse, *http.Response, error) {
	return r.ApiService.EnrollmentAddToExistingCertStoresExecute(r)
}

/*
EnrollmentAddToExistingCertStores Creates management jobs to install a newly enrolled pfx into the same certificate stores as the previous certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEnrollmentAddToExistingCertStoresRequest
*/
func (a *EnrollmentApiService) EnrollmentAddToExistingCertStores(ctx context.Context) ApiEnrollmentAddToExistingCertStoresRequest {
	return ApiEnrollmentAddToExistingCertStoresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorAPIModelsEnrollmentEnrollmentManagementResponse
func (a *EnrollmentApiService) EnrollmentAddToExistingCertStoresExecute(r ApiEnrollmentAddToExistingCertStoresRequest) (*KeyfactorAPIModelsEnrollmentEnrollmentManagementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorAPIModelsEnrollmentEnrollmentManagementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.EnrollmentAddToExistingCertStores")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Enrollment/PFX/Replace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentAvailableRenewalIdRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	id int32
	xKeyfactorRequestedWith *string
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentAvailableRenewalIdRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentAvailableRenewalIdRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The collection id for the given certificate
func (r ApiEnrollmentAvailableRenewalIdRequest) CollectionId(collectionId int32) ApiEnrollmentAvailableRenewalIdRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentAvailableRenewalIdRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentAvailableRenewalIdRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentAvailableRenewalIdRequest) Execute() (*ModelsEnrollmentAvailableRenewal, *http.Response, error) {
	return r.ApiService.EnrollmentAvailableRenewalIdExecute(r)
}

/*
EnrollmentAvailableRenewalId Returns the type of renewal available for a given certificate.

### Available Renewal Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 0              | None                 |
| 1             | Seeded PFX                |
| 2                | One-click                   |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The Keyfactor certificate Id
 @return ApiEnrollmentAvailableRenewalIdRequest
*/
func (a *EnrollmentApiService) EnrollmentAvailableRenewalId(ctx context.Context, id int32) ApiEnrollmentAvailableRenewalIdRequest {
	return ApiEnrollmentAvailableRenewalIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelsEnrollmentAvailableRenewal
func (a *EnrollmentApiService) EnrollmentAvailableRenewalIdExecute(r ApiEnrollmentAvailableRenewalIdRequest) (*ModelsEnrollmentAvailableRenewal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsEnrollmentAvailableRenewal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.EnrollmentAvailableRenewalId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Enrollment/AvailableRenewal/Id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentAvailableRenewalThumbprintRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	thumbprint string
	xKeyfactorRequestedWith *string
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentAvailableRenewalThumbprintRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentAvailableRenewalThumbprintRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The collection id for the given certificate
func (r ApiEnrollmentAvailableRenewalThumbprintRequest) CollectionId(collectionId int32) ApiEnrollmentAvailableRenewalThumbprintRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentAvailableRenewalThumbprintRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentAvailableRenewalThumbprintRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentAvailableRenewalThumbprintRequest) Execute() (*ModelsEnrollmentAvailableRenewal, *http.Response, error) {
	return r.ApiService.EnrollmentAvailableRenewalThumbprintExecute(r)
}

/*
EnrollmentAvailableRenewalThumbprint Returns the type of renewal available for a given certificate.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param thumbprint The certificate thumbprint
 @return ApiEnrollmentAvailableRenewalThumbprintRequest
*/
func (a *EnrollmentApiService) EnrollmentAvailableRenewalThumbprint(ctx context.Context, thumbprint string) ApiEnrollmentAvailableRenewalThumbprintRequest {
	return ApiEnrollmentAvailableRenewalThumbprintRequest{
		ApiService: a,
		ctx: ctx,
		thumbprint: thumbprint,
	}
}

// Execute executes the request
//  @return ModelsEnrollmentAvailableRenewal
func (a *EnrollmentApiService) EnrollmentAvailableRenewalThumbprintExecute(r ApiEnrollmentAvailableRenewalThumbprintRequest) (*ModelsEnrollmentAvailableRenewal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsEnrollmentAvailableRenewal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.EnrollmentAvailableRenewalThumbprint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Enrollment/AvailableRenewal/Thumbprint/{thumbprint}"
	localVarPath = strings.Replace(localVarPath, "{"+"thumbprint"+"}", url.PathEscape(parameterValueToString(r.thumbprint, "thumbprint")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentGetMyCSRContextRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentGetMyCSRContextRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentGetMyCSRContextRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentGetMyCSRContextRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentGetMyCSRContextRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentGetMyCSRContextRequest) Execute() (*CoreModelsEnrollmentEnrollmentTemplateCAResponse, *http.Response, error) {
	return r.ApiService.EnrollmentGetMyCSRContextExecute(r)
}

/*
EnrollmentGetMyCSRContext Returns the list of available CSR enrollment templates and their associated CA mappings that the calling user has permissions on

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEnrollmentGetMyCSRContextRequest
*/
func (a *EnrollmentApiService) EnrollmentGetMyCSRContext(ctx context.Context) ApiEnrollmentGetMyCSRContextRequest {
	return ApiEnrollmentGetMyCSRContextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreModelsEnrollmentEnrollmentTemplateCAResponse
func (a *EnrollmentApiService) EnrollmentGetMyCSRContextExecute(r ApiEnrollmentGetMyCSRContextRequest) (*CoreModelsEnrollmentEnrollmentTemplateCAResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreModelsEnrollmentEnrollmentTemplateCAResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.EnrollmentGetMyCSRContext")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Enrollment/CSR/Context/My"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentGetMyPFXContextRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentGetMyPFXContextRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentGetMyPFXContextRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentGetMyPFXContextRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentGetMyPFXContextRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentGetMyPFXContextRequest) Execute() (*CoreModelsEnrollmentEnrollmentTemplateCAResponse, *http.Response, error) {
	return r.ApiService.EnrollmentGetMyPFXContextExecute(r)
}

/*
EnrollmentGetMyPFXContext Returns the list of available PFX enrollment templates and their associated CA mappings that the calling user has permissions on

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEnrollmentGetMyPFXContextRequest
*/
func (a *EnrollmentApiService) EnrollmentGetMyPFXContext(ctx context.Context) ApiEnrollmentGetMyPFXContextRequest {
	return ApiEnrollmentGetMyPFXContextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoreModelsEnrollmentEnrollmentTemplateCAResponse
func (a *EnrollmentApiService) EnrollmentGetMyPFXContextExecute(r ApiEnrollmentGetMyPFXContextRequest) (*CoreModelsEnrollmentEnrollmentTemplateCAResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoreModelsEnrollmentEnrollmentTemplateCAResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.EnrollmentGetMyPFXContext")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Enrollment/PFX/Context/My"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentGetTemplateEnrollmentSettingsRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	id int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentGetTemplateEnrollmentSettingsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentGetTemplateEnrollmentSettingsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentGetTemplateEnrollmentSettingsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentGetTemplateEnrollmentSettingsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentGetTemplateEnrollmentSettingsRequest) Execute() (*KeyfactorApiModelsTemplatesTemplateEnrollmentSettingsResponse, *http.Response, error) {
	return r.ApiService.EnrollmentGetTemplateEnrollmentSettingsExecute(r)
}

/*
EnrollmentGetTemplateEnrollmentSettings Gets the template settings to use during enrollment. The response will be the resolved values for the settings.  If there is a template specific setting, the template specific setting will be used in the response.  If there is not a template specific setting, the global setting will be used in the response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiEnrollmentGetTemplateEnrollmentSettingsRequest
*/
func (a *EnrollmentApiService) EnrollmentGetTemplateEnrollmentSettings(ctx context.Context, id int32) ApiEnrollmentGetTemplateEnrollmentSettingsRequest {
	return ApiEnrollmentGetTemplateEnrollmentSettingsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsTemplatesTemplateEnrollmentSettingsResponse
func (a *EnrollmentApiService) EnrollmentGetTemplateEnrollmentSettingsExecute(r ApiEnrollmentGetTemplateEnrollmentSettingsRequest) (*KeyfactorApiModelsTemplatesTemplateEnrollmentSettingsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsTemplatesTemplateEnrollmentSettingsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.EnrollmentGetTemplateEnrollmentSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Enrollment/Settings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentInstallPFXToCertStoreRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	xKeyfactorRequestedWith *string
	request *KeyfactorApiModelsEnrollmentEnrollmentManagementRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentInstallPFXToCertStoreRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentInstallPFXToCertStoreRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The request to create the management jobs, which includes the request Id of the new pfx and the Ids and management job properties of the cert stores to add the pfx to
func (r ApiEnrollmentInstallPFXToCertStoreRequest) Request(request KeyfactorApiModelsEnrollmentEnrollmentManagementRequest) ApiEnrollmentInstallPFXToCertStoreRequest {
	r.request = &request
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentInstallPFXToCertStoreRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentInstallPFXToCertStoreRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentInstallPFXToCertStoreRequest) Execute() (*KeyfactorAPIModelsEnrollmentEnrollmentManagementResponse, *http.Response, error) {
	return r.ApiService.EnrollmentInstallPFXToCertStoreExecute(r)
}

/*
EnrollmentInstallPFXToCertStore Creates management jobs to install a newly enrolled pfx in to one or more certificate stores

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEnrollmentInstallPFXToCertStoreRequest
*/
func (a *EnrollmentApiService) EnrollmentInstallPFXToCertStore(ctx context.Context) ApiEnrollmentInstallPFXToCertStoreRequest {
	return ApiEnrollmentInstallPFXToCertStoreRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorAPIModelsEnrollmentEnrollmentManagementResponse
func (a *EnrollmentApiService) EnrollmentInstallPFXToCertStoreExecute(r ApiEnrollmentInstallPFXToCertStoreRequest) (*KeyfactorAPIModelsEnrollmentEnrollmentManagementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorAPIModelsEnrollmentEnrollmentManagementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.EnrollmentInstallPFXToCertStore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Enrollment/PFX/Deploy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentPostCSREnrollRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	xKeyfactorRequestedWith *string
	xCertificateformat *string
	request *ModelsEnrollmentCSREnrollmentRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentPostCSREnrollRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentPostCSREnrollRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired format [PEM, DER]
func (r ApiEnrollmentPostCSREnrollRequest) XCertificateformat(xCertificateformat string) ApiEnrollmentPostCSREnrollRequest {
	r.xCertificateformat = &xCertificateformat
	return r
}

// Information needed to perform the CSR Enrollment
func (r ApiEnrollmentPostCSREnrollRequest) Request(request ModelsEnrollmentCSREnrollmentRequest) ApiEnrollmentPostCSREnrollRequest {
	r.request = &request
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentPostCSREnrollRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentPostCSREnrollRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentPostCSREnrollRequest) Execute() (*ModelsEnrollmentCSREnrollmentResponse, *http.Response, error) {
	return r.ApiService.EnrollmentPostCSREnrollExecute(r)
}

/*
EnrollmentPostCSREnroll Performs a CSR Enrollment based upon the provided request

### Subject Alternative Name Flags ###
| Value              | Description               |
|--------------------|---------------------------|
| other              | OtherName                 |
| rfc822             | RFC822Name                |
| dns                | DNSName                   |
| x400               | X400Address               |
| directory          | DirectoryName             |
| ediparty           | EdipartyName              |
| uri                | UniformResourceIdentifier |
| ip                 | IPAddress                 |
| ip4                | IPv4Address               |
| ip6                | IPv6Address               |
| registeredid       | RegisteredId              |
| ms_ntprincipalname | MS_NTPrincipalName        |
| ms_ntdsreplication | MS_NTDSReplication        |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEnrollmentPostCSREnrollRequest
*/
func (a *EnrollmentApiService) EnrollmentPostCSREnroll(ctx context.Context) ApiEnrollmentPostCSREnrollRequest {
	return ApiEnrollmentPostCSREnrollRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelsEnrollmentCSREnrollmentResponse
func (a *EnrollmentApiService) EnrollmentPostCSREnrollExecute(r ApiEnrollmentPostCSREnrollRequest) (*ModelsEnrollmentCSREnrollmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsEnrollmentCSREnrollmentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.EnrollmentPostCSREnroll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Enrollment/CSR"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.xCertificateformat == nil {
		return localVarReturnValue, nil, reportError("xCertificateformat is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	parameterAddToQuery(localVarQueryParams, "x-certificateformat", r.xCertificateformat, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentPostPFXEnrollRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	xKeyfactorRequestedWith *string
	xCertificateformat *string
	request *ModelsEnrollmentPFXEnrollmentRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentPostPFXEnrollRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentPostPFXEnrollRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired format [PFX, Zip, STORE]
func (r ApiEnrollmentPostPFXEnrollRequest) XCertificateformat(xCertificateformat string) ApiEnrollmentPostPFXEnrollRequest {
	r.xCertificateformat = &xCertificateformat
	return r
}

// The information needed to perform the PFX Enrollment
func (r ApiEnrollmentPostPFXEnrollRequest) Request(request ModelsEnrollmentPFXEnrollmentRequest) ApiEnrollmentPostPFXEnrollRequest {
	r.request = &request
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentPostPFXEnrollRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentPostPFXEnrollRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentPostPFXEnrollRequest) Execute() (*ModelsEnrollmentPFXEnrollmentResponse, *http.Response, error) {
	return r.ApiService.EnrollmentPostPFXEnrollExecute(r)
}

/*
EnrollmentPostPFXEnroll Performs a PFX Enrollment based upon the provided request

### IMPORTANT: 
- The <b>'RenewalCertificateId'</b> field in the request should be set to <b>null</b> if the certificate is not being renewed as part of the enrollment. A value of <b>0</b> will produce an error.

### Subject Alternative Name Flags ###
| Value              | Description               |
|--------------------|---------------------------|
| other              | OtherName                 |
| rfc822             | RFC822Name                |
| dns                | DNSName                   |
| x400               | X400Address               |
| directory          | DirectoryName             |
| ediparty           | EdipartyName              |
| uri                | UniformResourceIdentifier |
| ip                 | IPAddress                 |
| ip4                | IPv4Address               |
| ip6                | IPv6Address               |
| registeredid       | RegisteredId              |
| ms_ntprincipalname | MS_NTPrincipalName        |
| ms_ntdsreplication | MS_NTDSReplication        |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEnrollmentPostPFXEnrollRequest
*/
func (a *EnrollmentApiService) EnrollmentPostPFXEnroll(ctx context.Context) ApiEnrollmentPostPFXEnrollRequest {
	return ApiEnrollmentPostPFXEnrollRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelsEnrollmentPFXEnrollmentResponse
func (a *EnrollmentApiService) EnrollmentPostPFXEnrollExecute(r ApiEnrollmentPostPFXEnrollRequest) (*ModelsEnrollmentPFXEnrollmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsEnrollmentPFXEnrollmentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.EnrollmentPostPFXEnroll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Enrollment/PFX"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.xCertificateformat == nil {
		return localVarReturnValue, nil, reportError("xCertificateformat is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	parameterAddToQuery(localVarQueryParams, "x-certificateformat", r.xCertificateformat, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentPostParsedCSRRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	xKeyfactorRequestedWith *string
	csr *ModelsCSRContents
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentPostParsedCSRRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentPostParsedCSRRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// CSR to be parsed
func (r ApiEnrollmentPostParsedCSRRequest) Csr(csr ModelsCSRContents) ApiEnrollmentPostParsedCSRRequest {
	r.csr = &csr
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentPostParsedCSRRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentPostParsedCSRRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentPostParsedCSRRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.EnrollmentPostParsedCSRExecute(r)
}

/*
EnrollmentPostParsedCSR Parses the provided CSR and returns the properties

This functionality is equivalent to the result of pasting a CSR into the field within the Management Portal CSR Enrollment page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEnrollmentPostParsedCSRRequest
*/
func (a *EnrollmentApiService) EnrollmentPostParsedCSR(ctx context.Context) ApiEnrollmentPostParsedCSRRequest {
	return ApiEnrollmentPostParsedCSRRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *EnrollmentApiService) EnrollmentPostParsedCSRExecute(r ApiEnrollmentPostParsedCSRRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.EnrollmentPostParsedCSR")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Enrollment/CSR/Parse"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.csr == nil {
		return localVarReturnValue, nil, reportError("csr is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.csr
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentRenewRequest struct {
	ctx context.Context
	ApiService *EnrollmentApiService
	xKeyfactorRequestedWith *string
	request *ModelsEnrollmentRenewalRequest
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentRenewRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentRenewRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The information needed to perform the renewal
func (r ApiEnrollmentRenewRequest) Request(request ModelsEnrollmentRenewalRequest) ApiEnrollmentRenewRequest {
	r.request = &request
	return r
}

// The collection id for the given certificate
func (r ApiEnrollmentRenewRequest) CollectionId(collectionId int32) ApiEnrollmentRenewRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentRenewRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentRenewRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentRenewRequest) Execute() (*ModelsEnrollmentRenewalResponse, *http.Response, error) {
	return r.ApiService.EnrollmentRenewExecute(r)
}

/*
EnrollmentRenew Performs a renewal based upon the passed in request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEnrollmentRenewRequest
*/
func (a *EnrollmentApiService) EnrollmentRenew(ctx context.Context) ApiEnrollmentRenewRequest {
	return ApiEnrollmentRenewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelsEnrollmentRenewalResponse
func (a *EnrollmentApiService) EnrollmentRenewExecute(r ApiEnrollmentRenewRequest) (*ModelsEnrollmentRenewalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsEnrollmentRenewalResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnrollmentApiService.EnrollmentRenew")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Enrollment/Renew"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
