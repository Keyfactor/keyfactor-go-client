/*
Keyfactor-v1

This reference serves to document REST-based methods to manage and integrate with Keyfactor. In addition, an embedded interface allows for the execution of calls against the current Keyfactor API instance.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keyfactor_command_client_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// CertificateCollectionApiService CertificateCollectionApi service
type CertificateCollectionApiService service

type ApiCertificateCollectionCopyFromExistingCollectionRequest struct {
	ctx context.Context
	ApiService *CertificateCollectionApiService
	xKeyfactorRequestedWith *string
	request *KeyfactorApiModelsCertificateCollectionsCertificateCollectionCopyRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateCollectionCopyFromExistingCollectionRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateCollectionCopyFromExistingCollectionRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Information related to the certificate collection query
func (r ApiCertificateCollectionCopyFromExistingCollectionRequest) Request(request KeyfactorApiModelsCertificateCollectionsCertificateCollectionCopyRequest) ApiCertificateCollectionCopyFromExistingCollectionRequest {
	r.request = &request
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateCollectionCopyFromExistingCollectionRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateCollectionCopyFromExistingCollectionRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateCollectionCopyFromExistingCollectionRequest) Execute() (*KeyfactorApiModelsCertificateCollectionsCertificateCollectionResponse, *http.Response, error) {
	return r.ApiService.CertificateCollectionCopyFromExistingCollectionExecute(r)
}

/*
CertificateCollectionCopyFromExistingCollection Creates a new certificate collection from an existing collection. The permissions, query and description of the   existing collection are copied when creating the new record, with the option to overwrite the query or description.

### Duplication Field Values ###
The field used to determine if a certificate is a duplicate of another.
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | Common name               |
| 2                  | Distinguished name        |
| 3                  | Principal name            |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateCollectionCopyFromExistingCollectionRequest
*/
func (a *CertificateCollectionApiService) CertificateCollectionCopyFromExistingCollection(ctx context.Context) ApiCertificateCollectionCopyFromExistingCollectionRequest {
	return ApiCertificateCollectionCopyFromExistingCollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsCertificateCollectionsCertificateCollectionResponse
func (a *CertificateCollectionApiService) CertificateCollectionCopyFromExistingCollectionExecute(r ApiCertificateCollectionCopyFromExistingCollectionRequest) (*KeyfactorApiModelsCertificateCollectionsCertificateCollectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsCertificateCollectionsCertificateCollectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateCollectionApiService.CertificateCollectionCopyFromExistingCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CertificateCollections/Copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateCollectionCreateCollectionRequest struct {
	ctx context.Context
	ApiService *CertificateCollectionApiService
	xKeyfactorRequestedWith *string
	request *KeyfactorApiModelsCertificateCollectionsCertificateCollectionCreateRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateCollectionCreateCollectionRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateCollectionCreateCollectionRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Information related to the certificate collection query
func (r ApiCertificateCollectionCreateCollectionRequest) Request(request KeyfactorApiModelsCertificateCollectionsCertificateCollectionCreateRequest) ApiCertificateCollectionCreateCollectionRequest {
	r.request = &request
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateCollectionCreateCollectionRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateCollectionCreateCollectionRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateCollectionCreateCollectionRequest) Execute() (*KeyfactorApiModelsCertificateCollectionsCertificateCollectionResponse, *http.Response, error) {
	return r.ApiService.CertificateCollectionCreateCollectionExecute(r)
}

/*
CertificateCollectionCreateCollection Creates a new certificate collection with the provided properties

### Duplication Field Values ###
The field used to determine if a certificate is a duplicate of another.
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | Common name               |
| 2                  | Distinguished name        |
| 3                  | Principal name            |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateCollectionCreateCollectionRequest
*/
func (a *CertificateCollectionApiService) CertificateCollectionCreateCollection(ctx context.Context) ApiCertificateCollectionCreateCollectionRequest {
	return ApiCertificateCollectionCreateCollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsCertificateCollectionsCertificateCollectionResponse
func (a *CertificateCollectionApiService) CertificateCollectionCreateCollectionExecute(r ApiCertificateCollectionCreateCollectionRequest) (*KeyfactorApiModelsCertificateCollectionsCertificateCollectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsCertificateCollectionsCertificateCollectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateCollectionApiService.CertificateCollectionCreateCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CertificateCollections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateCollectionGetCollection0Request struct {
	ctx context.Context
	ApiService *CertificateCollectionApiService
	id int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateCollectionGetCollection0Request) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateCollectionGetCollection0Request {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateCollectionGetCollection0Request) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateCollectionGetCollection0Request {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateCollectionGetCollection0Request) Execute() (*ModelsCertificateQuery, *http.Response, error) {
	return r.ApiService.CertificateCollectionGetCollection0Execute(r)
}

/*
CertificateCollectionGetCollection0 Returns the certificate collection definition associated with the provided Keyfactor identifier

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifier of the certificate collection
 @return ApiCertificateCollectionGetCollection0Request
*/
func (a *CertificateCollectionApiService) CertificateCollectionGetCollection0(ctx context.Context, id int32) ApiCertificateCollectionGetCollection0Request {
	return ApiCertificateCollectionGetCollection0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelsCertificateQuery
func (a *CertificateCollectionApiService) CertificateCollectionGetCollection0Execute(r ApiCertificateCollectionGetCollection0Request) (*ModelsCertificateQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsCertificateQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateCollectionApiService.CertificateCollectionGetCollection0")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CertificateCollections/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateCollectionGetCollection1Request struct {
	ctx context.Context
	ApiService *CertificateCollectionApiService
	name string
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateCollectionGetCollection1Request) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateCollectionGetCollection1Request {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateCollectionGetCollection1Request) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateCollectionGetCollection1Request {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateCollectionGetCollection1Request) Execute() (*ModelsCertificateQuery, *http.Response, error) {
	return r.ApiService.CertificateCollectionGetCollection1Execute(r)
}

/*
CertificateCollectionGetCollection1 Returns the certificate collection associated with the provided collection name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the Collection
 @return ApiCertificateCollectionGetCollection1Request
*/
func (a *CertificateCollectionApiService) CertificateCollectionGetCollection1(ctx context.Context, name string) ApiCertificateCollectionGetCollection1Request {
	return ApiCertificateCollectionGetCollection1Request{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ModelsCertificateQuery
func (a *CertificateCollectionApiService) CertificateCollectionGetCollection1Execute(r ApiCertificateCollectionGetCollection1Request) (*ModelsCertificateQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsCertificateQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateCollectionApiService.CertificateCollectionGetCollection1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CertificateCollections/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateCollectionGetCollectionsRequest struct {
	ctx context.Context
	ApiService *CertificateCollectionApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
	pqQueryString *string
	pqPageReturned *int32
	pqReturnLimit *int32
	pqSortField *string
	pqSortAscending *int32
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateCollectionGetCollectionsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateCollectionGetCollectionsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateCollectionGetCollectionsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateCollectionGetCollectionsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Contents of the query (ex: field1 -eq value1 AND field2 -gt value2)
func (r ApiCertificateCollectionGetCollectionsRequest) PqQueryString(pqQueryString string) ApiCertificateCollectionGetCollectionsRequest {
	r.pqQueryString = &pqQueryString
	return r
}

// The current page within the result set to be returned
func (r ApiCertificateCollectionGetCollectionsRequest) PqPageReturned(pqPageReturned int32) ApiCertificateCollectionGetCollectionsRequest {
	r.pqPageReturned = &pqPageReturned
	return r
}

// Maximum number of records to be returned in a single call
func (r ApiCertificateCollectionGetCollectionsRequest) PqReturnLimit(pqReturnLimit int32) ApiCertificateCollectionGetCollectionsRequest {
	r.pqReturnLimit = &pqReturnLimit
	return r
}

// Field by which the results should be sorted (view results via Management Portal for sortable columns)
func (r ApiCertificateCollectionGetCollectionsRequest) PqSortField(pqSortField string) ApiCertificateCollectionGetCollectionsRequest {
	r.pqSortField = &pqSortField
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiCertificateCollectionGetCollectionsRequest) PqSortAscending(pqSortAscending int32) ApiCertificateCollectionGetCollectionsRequest {
	r.pqSortAscending = &pqSortAscending
	return r
}

func (r ApiCertificateCollectionGetCollectionsRequest) Execute() ([]ModelsCertificateQuery, *http.Response, error) {
	return r.ApiService.CertificateCollectionGetCollectionsExecute(r)
}

/*
CertificateCollectionGetCollections Returns all certificate collections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateCollectionGetCollectionsRequest
*/
func (a *CertificateCollectionApiService) CertificateCollectionGetCollections(ctx context.Context) ApiCertificateCollectionGetCollectionsRequest {
	return ApiCertificateCollectionGetCollectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelsCertificateQuery
func (a *CertificateCollectionApiService) CertificateCollectionGetCollectionsExecute(r ApiCertificateCollectionGetCollectionsRequest) ([]ModelsCertificateQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelsCertificateQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateCollectionApiService.CertificateCollectionGetCollections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CertificateCollections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.pqQueryString != nil {
		parameterAddToQuery(localVarQueryParams, "pq.queryString", r.pqQueryString, "")
	}
	if r.pqPageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "pq.pageReturned", r.pqPageReturned, "")
	}
	if r.pqReturnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "pq.returnLimit", r.pqReturnLimit, "")
	}
	if r.pqSortField != nil {
		parameterAddToQuery(localVarQueryParams, "pq.sortField", r.pqSortField, "")
	}
	if r.pqSortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "pq.sortAscending", r.pqSortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateCollectionSetCollectionPermissionsRequest struct {
	ctx context.Context
	ApiService *CertificateCollectionApiService
	id int32
	xKeyfactorRequestedWith *string
	collectionPermissions *[]ModelsCollectionRolePermissions
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateCollectionSetCollectionPermissionsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateCollectionSetCollectionPermissionsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The collection Permissions object [&#39;Read&#39;, &#39;EditMetadata&#39;, &#39;Recover&#39;, &#39;Revoke&#39;, &#39;Delete&#39;]
func (r ApiCertificateCollectionSetCollectionPermissionsRequest) CollectionPermissions(collectionPermissions []ModelsCollectionRolePermissions) ApiCertificateCollectionSetCollectionPermissionsRequest {
	r.collectionPermissions = &collectionPermissions
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateCollectionSetCollectionPermissionsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateCollectionSetCollectionPermissionsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateCollectionSetCollectionPermissionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateCollectionSetCollectionPermissionsExecute(r)
}

/*
CertificateCollectionSetCollectionPermissions Set the permissions for a collection

This endpoint should not be used as its use will potentially cause users to lose access to collections they previously had access to. This endpoint will be removed in version 11.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The collection to set permissions on
 @return ApiCertificateCollectionSetCollectionPermissionsRequest

Deprecated
*/
func (a *CertificateCollectionApiService) CertificateCollectionSetCollectionPermissions(ctx context.Context, id int32) ApiCertificateCollectionSetCollectionPermissionsRequest {
	return ApiCertificateCollectionSetCollectionPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
// Deprecated
func (a *CertificateCollectionApiService) CertificateCollectionSetCollectionPermissionsExecute(r ApiCertificateCollectionSetCollectionPermissionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateCollectionApiService.CertificateCollectionSetCollectionPermissions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CertificateCollections/{id}/Permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.collectionPermissions == nil {
		return nil, reportError("collectionPermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.collectionPermissions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateCollectionUpdateCollectionRequest struct {
	ctx context.Context
	ApiService *CertificateCollectionApiService
	xKeyfactorRequestedWith *string
	request *KeyfactorApiModelsCertificateCollectionsCertificateCollectionUpdateRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateCollectionUpdateCollectionRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateCollectionUpdateCollectionRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Information related to the certificate collection query
func (r ApiCertificateCollectionUpdateCollectionRequest) Request(request KeyfactorApiModelsCertificateCollectionsCertificateCollectionUpdateRequest) ApiCertificateCollectionUpdateCollectionRequest {
	r.request = &request
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateCollectionUpdateCollectionRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateCollectionUpdateCollectionRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateCollectionUpdateCollectionRequest) Execute() (*KeyfactorApiModelsCertificateCollectionsCertificateCollectionResponse, *http.Response, error) {
	return r.ApiService.CertificateCollectionUpdateCollectionExecute(r)
}

/*
CertificateCollectionUpdateCollection Updates an existing certificate collection with the provided properties

### Duplication Field Values ###
The field used to determine if a certificate is a duplicate of another.
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | Common name               |
| 2                  | Distinguished name        |
| 3                  | Principal name            |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateCollectionUpdateCollectionRequest
*/
func (a *CertificateCollectionApiService) CertificateCollectionUpdateCollection(ctx context.Context) ApiCertificateCollectionUpdateCollectionRequest {
	return ApiCertificateCollectionUpdateCollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsCertificateCollectionsCertificateCollectionResponse
func (a *CertificateCollectionApiService) CertificateCollectionUpdateCollectionExecute(r ApiCertificateCollectionUpdateCollectionRequest) (*KeyfactorApiModelsCertificateCollectionsCertificateCollectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsCertificateCollectionsCertificateCollectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateCollectionApiService.CertificateCollectionUpdateCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CertificateCollections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
