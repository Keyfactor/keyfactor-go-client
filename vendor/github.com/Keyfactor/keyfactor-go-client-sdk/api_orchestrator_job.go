/*
Keyfactor-v1

This reference serves to document REST-based methods to manage and integrate with Keyfactor. In addition, an embedded interface allows for the execution of calls against the current Keyfactor API instance.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keyfactor_command_client_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// OrchestratorJobApiService OrchestratorJobApi service
type OrchestratorJobApiService service

type ApiOrchestratorJobAcknowledgeJobsRequest struct {
	ctx context.Context
	ApiService *OrchestratorJobApiService
	xKeyfactorRequestedWith *string
	req *KeyfactorApiModelsOrchestratorJobsAcknowledgeJobRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobAcknowledgeJobsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobAcknowledgeJobsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Information to identify the jobs to acknowledge, either a query or a list of job identifiers
func (r ApiOrchestratorJobAcknowledgeJobsRequest) Req(req KeyfactorApiModelsOrchestratorJobsAcknowledgeJobRequest) ApiOrchestratorJobAcknowledgeJobsRequest {
	r.req = &req
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobAcknowledgeJobsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobAcknowledgeJobsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiOrchestratorJobAcknowledgeJobsRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrchestratorJobAcknowledgeJobsExecute(r)
}

/*
OrchestratorJobAcknowledgeJobs Acknowledges orchestrator jobs based on the provided information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrchestratorJobAcknowledgeJobsRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobAcknowledgeJobs(ctx context.Context) ApiOrchestratorJobAcknowledgeJobsRequest {
	return ApiOrchestratorJobAcknowledgeJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OrchestratorJobApiService) OrchestratorJobAcknowledgeJobsExecute(r ApiOrchestratorJobAcknowledgeJobsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestratorJobApiService.OrchestratorJobAcknowledgeJobs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OrchestratorJobs/Acknowledge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.req == nil {
		return nil, reportError("req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.req
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrchestratorJobGetCustomJobResultDataRequest struct {
	ctx context.Context
	ApiService *OrchestratorJobApiService
	jobHistoryId *int64
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Identifier of the job history record to retrieve
func (r ApiOrchestratorJobGetCustomJobResultDataRequest) JobHistoryId(jobHistoryId int64) ApiOrchestratorJobGetCustomJobResultDataRequest {
	r.jobHistoryId = &jobHistoryId
	return r
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobGetCustomJobResultDataRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobGetCustomJobResultDataRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobGetCustomJobResultDataRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobGetCustomJobResultDataRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiOrchestratorJobGetCustomJobResultDataRequest) Execute() (*KeyfactorApiModelsOrchestratorJobsCustomJobResultDataResponse, *http.Response, error) {
	return r.ApiService.OrchestratorJobGetCustomJobResultDataExecute(r)
}

/*
OrchestratorJobGetCustomJobResultData Retrieves the results of a custom job using the provided information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrchestratorJobGetCustomJobResultDataRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobGetCustomJobResultData(ctx context.Context) ApiOrchestratorJobGetCustomJobResultDataRequest {
	return ApiOrchestratorJobGetCustomJobResultDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsOrchestratorJobsCustomJobResultDataResponse
func (a *OrchestratorJobApiService) OrchestratorJobGetCustomJobResultDataExecute(r ApiOrchestratorJobGetCustomJobResultDataRequest) (*KeyfactorApiModelsOrchestratorJobsCustomJobResultDataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsOrchestratorJobsCustomJobResultDataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestratorJobApiService.OrchestratorJobGetCustomJobResultData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OrchestratorJobs/JobStatus/Data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobHistoryId == nil {
		return localVarReturnValue, nil, reportError("jobHistoryId is required and must be specified")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "jobHistoryId", r.jobHistoryId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrchestratorJobGetJobHistoryRequest struct {
	ctx context.Context
	ApiService *OrchestratorJobApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
	pqQueryString *string
	pqPageReturned *int32
	pqReturnLimit *int32
	pqSortField *string
	pqSortAscending *int32
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobGetJobHistoryRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobGetJobHistoryRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobGetJobHistoryRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobGetJobHistoryRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Contents of the query (ex: field1 -eq value1 AND field2 -gt value2)
func (r ApiOrchestratorJobGetJobHistoryRequest) PqQueryString(pqQueryString string) ApiOrchestratorJobGetJobHistoryRequest {
	r.pqQueryString = &pqQueryString
	return r
}

// The current page within the result set to be returned
func (r ApiOrchestratorJobGetJobHistoryRequest) PqPageReturned(pqPageReturned int32) ApiOrchestratorJobGetJobHistoryRequest {
	r.pqPageReturned = &pqPageReturned
	return r
}

// Maximum number of records to be returned in a single call
func (r ApiOrchestratorJobGetJobHistoryRequest) PqReturnLimit(pqReturnLimit int32) ApiOrchestratorJobGetJobHistoryRequest {
	r.pqReturnLimit = &pqReturnLimit
	return r
}

// Field by which the results should be sorted (view results via Management Portal for sortable columns)
func (r ApiOrchestratorJobGetJobHistoryRequest) PqSortField(pqSortField string) ApiOrchestratorJobGetJobHistoryRequest {
	r.pqSortField = &pqSortField
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiOrchestratorJobGetJobHistoryRequest) PqSortAscending(pqSortAscending int32) ApiOrchestratorJobGetJobHistoryRequest {
	r.pqSortAscending = &pqSortAscending
	return r
}

func (r ApiOrchestratorJobGetJobHistoryRequest) Execute() ([]KeyfactorApiModelsCertificateStoresJobHistoryResponse, *http.Response, error) {
	return r.ApiService.OrchestratorJobGetJobHistoryExecute(r)
}

/*
OrchestratorJobGetJobHistory Returns all histories of an orchestrator job according to the provided filter and output parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrchestratorJobGetJobHistoryRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobGetJobHistory(ctx context.Context) ApiOrchestratorJobGetJobHistoryRequest {
	return ApiOrchestratorJobGetJobHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsCertificateStoresJobHistoryResponse
func (a *OrchestratorJobApiService) OrchestratorJobGetJobHistoryExecute(r ApiOrchestratorJobGetJobHistoryRequest) ([]KeyfactorApiModelsCertificateStoresJobHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsCertificateStoresJobHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestratorJobApiService.OrchestratorJobGetJobHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OrchestratorJobs/JobHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.pqQueryString != nil {
		parameterAddToQuery(localVarQueryParams, "pq.queryString", r.pqQueryString, "")
	}
	if r.pqPageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "pq.pageReturned", r.pqPageReturned, "")
	}
	if r.pqReturnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "pq.returnLimit", r.pqReturnLimit, "")
	}
	if r.pqSortField != nil {
		parameterAddToQuery(localVarQueryParams, "pq.sortField", r.pqSortField, "")
	}
	if r.pqSortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "pq.sortAscending", r.pqSortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrchestratorJobGetScheduledJobsRequest struct {
	ctx context.Context
	ApiService *OrchestratorJobApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
	pqQueryString *string
	pqPageReturned *int32
	pqReturnLimit *int32
	pqSortField *string
	pqSortAscending *int32
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobGetScheduledJobsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobGetScheduledJobsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobGetScheduledJobsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobGetScheduledJobsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Contents of the query (ex: field1 -eq value1 AND field2 -gt value2)
func (r ApiOrchestratorJobGetScheduledJobsRequest) PqQueryString(pqQueryString string) ApiOrchestratorJobGetScheduledJobsRequest {
	r.pqQueryString = &pqQueryString
	return r
}

// The current page within the result set to be returned
func (r ApiOrchestratorJobGetScheduledJobsRequest) PqPageReturned(pqPageReturned int32) ApiOrchestratorJobGetScheduledJobsRequest {
	r.pqPageReturned = &pqPageReturned
	return r
}

// Maximum number of records to be returned in a single call
func (r ApiOrchestratorJobGetScheduledJobsRequest) PqReturnLimit(pqReturnLimit int32) ApiOrchestratorJobGetScheduledJobsRequest {
	r.pqReturnLimit = &pqReturnLimit
	return r
}

// Field by which the results should be sorted (view results via Management Portal for sortable columns)
func (r ApiOrchestratorJobGetScheduledJobsRequest) PqSortField(pqSortField string) ApiOrchestratorJobGetScheduledJobsRequest {
	r.pqSortField = &pqSortField
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiOrchestratorJobGetScheduledJobsRequest) PqSortAscending(pqSortAscending int32) ApiOrchestratorJobGetScheduledJobsRequest {
	r.pqSortAscending = &pqSortAscending
	return r
}

func (r ApiOrchestratorJobGetScheduledJobsRequest) Execute() ([]ModelsOrchestratorJobsJob, *http.Response, error) {
	return r.ApiService.OrchestratorJobGetScheduledJobsExecute(r)
}

/*
OrchestratorJobGetScheduledJobs Returns all scheduled orchestrator jobs according to the provided filter and output parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrchestratorJobGetScheduledJobsRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobGetScheduledJobs(ctx context.Context) ApiOrchestratorJobGetScheduledJobsRequest {
	return ApiOrchestratorJobGetScheduledJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelsOrchestratorJobsJob
func (a *OrchestratorJobApiService) OrchestratorJobGetScheduledJobsExecute(r ApiOrchestratorJobGetScheduledJobsRequest) ([]ModelsOrchestratorJobsJob, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelsOrchestratorJobsJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestratorJobApiService.OrchestratorJobGetScheduledJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OrchestratorJobs/ScheduledJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.pqQueryString != nil {
		parameterAddToQuery(localVarQueryParams, "pq.queryString", r.pqQueryString, "")
	}
	if r.pqPageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "pq.pageReturned", r.pqPageReturned, "")
	}
	if r.pqReturnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "pq.returnLimit", r.pqReturnLimit, "")
	}
	if r.pqSortField != nil {
		parameterAddToQuery(localVarQueryParams, "pq.sortField", r.pqSortField, "")
	}
	if r.pqSortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "pq.sortAscending", r.pqSortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrchestratorJobRescheduleJobsRequest struct {
	ctx context.Context
	ApiService *OrchestratorJobApiService
	xKeyfactorRequestedWith *string
	req *KeyfactorApiModelsOrchestratorJobsRescheduleJobRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobRescheduleJobsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobRescheduleJobsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Information to identify the jobs to reschedule, either a query or a list of job identifiers
func (r ApiOrchestratorJobRescheduleJobsRequest) Req(req KeyfactorApiModelsOrchestratorJobsRescheduleJobRequest) ApiOrchestratorJobRescheduleJobsRequest {
	r.req = &req
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobRescheduleJobsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobRescheduleJobsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiOrchestratorJobRescheduleJobsRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrchestratorJobRescheduleJobsExecute(r)
}

/*
OrchestratorJobRescheduleJobs Reschedules orchestrator jobs based on the provided information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrchestratorJobRescheduleJobsRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobRescheduleJobs(ctx context.Context) ApiOrchestratorJobRescheduleJobsRequest {
	return ApiOrchestratorJobRescheduleJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OrchestratorJobApiService) OrchestratorJobRescheduleJobsExecute(r ApiOrchestratorJobRescheduleJobsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestratorJobApiService.OrchestratorJobRescheduleJobs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OrchestratorJobs/Reschedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.req == nil {
		return nil, reportError("req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.req
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrchestratorJobScheduleBulkJobRequest struct {
	ctx context.Context
	ApiService *OrchestratorJobApiService
	xKeyfactorRequestedWith *string
	req *ModelsOrchestratorJobsScheduleBulkJobRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobScheduleBulkJobRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobScheduleBulkJobRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Information to use to schedule the jobs, including the type of custom job, agents to use, and job-specific parameters.
func (r ApiOrchestratorJobScheduleBulkJobRequest) Req(req ModelsOrchestratorJobsScheduleBulkJobRequest) ApiOrchestratorJobScheduleBulkJobRequest {
	r.req = &req
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobScheduleBulkJobRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobScheduleBulkJobRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiOrchestratorJobScheduleBulkJobRequest) Execute() (*KeyfactorApiModelsOrchestratorJobsBulkJobResponse, *http.Response, error) {
	return r.ApiService.OrchestratorJobScheduleBulkJobExecute(r)
}

/*
OrchestratorJobScheduleBulkJob Schedules the same job for a custom JobType on the specified agents using the provided information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrchestratorJobScheduleBulkJobRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobScheduleBulkJob(ctx context.Context) ApiOrchestratorJobScheduleBulkJobRequest {
	return ApiOrchestratorJobScheduleBulkJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsOrchestratorJobsBulkJobResponse
func (a *OrchestratorJobApiService) OrchestratorJobScheduleBulkJobExecute(r ApiOrchestratorJobScheduleBulkJobRequest) (*KeyfactorApiModelsOrchestratorJobsBulkJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsOrchestratorJobsBulkJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestratorJobApiService.OrchestratorJobScheduleBulkJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OrchestratorJobs/Custom/Bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.req == nil {
		return localVarReturnValue, nil, reportError("req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.req
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrchestratorJobScheduleJobRequest struct {
	ctx context.Context
	ApiService *OrchestratorJobApiService
	xKeyfactorRequestedWith *string
	req *ModelsOrchestratorJobsScheduleJobRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobScheduleJobRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobScheduleJobRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Information to use to schedule the job, including the type of custom job, agent to use, and job-specific parameters.
func (r ApiOrchestratorJobScheduleJobRequest) Req(req ModelsOrchestratorJobsScheduleJobRequest) ApiOrchestratorJobScheduleJobRequest {
	r.req = &req
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobScheduleJobRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobScheduleJobRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiOrchestratorJobScheduleJobRequest) Execute() (*KeyfactorApiModelsOrchestratorJobsJobResponse, *http.Response, error) {
	return r.ApiService.OrchestratorJobScheduleJobExecute(r)
}

/*
OrchestratorJobScheduleJob Schedules a job for a custom JobType on the agent using the provided information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrchestratorJobScheduleJobRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobScheduleJob(ctx context.Context) ApiOrchestratorJobScheduleJobRequest {
	return ApiOrchestratorJobScheduleJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsOrchestratorJobsJobResponse
func (a *OrchestratorJobApiService) OrchestratorJobScheduleJobExecute(r ApiOrchestratorJobScheduleJobRequest) (*KeyfactorApiModelsOrchestratorJobsJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsOrchestratorJobsJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestratorJobApiService.OrchestratorJobScheduleJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OrchestratorJobs/Custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.req == nil {
		return localVarReturnValue, nil, reportError("req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.req
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrchestratorJobUnscheduleJobsRequest struct {
	ctx context.Context
	ApiService *OrchestratorJobApiService
	xKeyfactorRequestedWith *string
	req *KeyfactorApiModelsOrchestratorJobsUnscheduleJobRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobUnscheduleJobsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobUnscheduleJobsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Information to identify the orchestrator jobs to unschedule, either a query or a list of job identifiers
func (r ApiOrchestratorJobUnscheduleJobsRequest) Req(req KeyfactorApiModelsOrchestratorJobsUnscheduleJobRequest) ApiOrchestratorJobUnscheduleJobsRequest {
	r.req = &req
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobUnscheduleJobsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobUnscheduleJobsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiOrchestratorJobUnscheduleJobsRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrchestratorJobUnscheduleJobsExecute(r)
}

/*
OrchestratorJobUnscheduleJobs Unschedules orchestrator jobs based on the provided information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrchestratorJobUnscheduleJobsRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobUnscheduleJobs(ctx context.Context) ApiOrchestratorJobUnscheduleJobsRequest {
	return ApiOrchestratorJobUnscheduleJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OrchestratorJobApiService) OrchestratorJobUnscheduleJobsExecute(r ApiOrchestratorJobUnscheduleJobsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestratorJobApiService.OrchestratorJobUnscheduleJobs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OrchestratorJobs/Unschedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.req == nil {
		return nil, reportError("req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.req
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
