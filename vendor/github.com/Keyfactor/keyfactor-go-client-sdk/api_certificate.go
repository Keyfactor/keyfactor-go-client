/*
Keyfactor-v1

This reference serves to document REST-based methods to manage and integrate with Keyfactor. In addition, an embedded interface allows for the execution of calls against the current Keyfactor API instance.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keyfactor_command_client_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// CertificateApiService CertificateApi service
type CertificateApiService service

type ApiCertificateAnalyzeCertRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	xKeyfactorRequestedWith *string
	request *KeyfactorApiModelsCertificatesAnalyzeCertificateRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAnalyzeCertRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAnalyzeCertRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The certificate to analyze
func (r ApiCertificateAnalyzeCertRequest) Request(request KeyfactorApiModelsCertificatesAnalyzeCertificateRequest) ApiCertificateAnalyzeCertRequest {
	r.request = &request
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAnalyzeCertRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAnalyzeCertRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAnalyzeCertRequest) Execute() ([]ModelsCertificateDetails, *http.Response, error) {
	return r.ApiService.CertificateAnalyzeCertExecute(r)
}

/*
CertificateAnalyzeCert Returns the public information of the certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateAnalyzeCertRequest
*/
func (a *CertificateApiService) CertificateAnalyzeCert(ctx context.Context) ApiCertificateAnalyzeCertRequest {
	return ApiCertificateAnalyzeCertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelsCertificateDetails
func (a *CertificateApiService) CertificateAnalyzeCertExecute(r ApiCertificateAnalyzeCertRequest) ([]ModelsCertificateDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelsCertificateDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateAnalyzeCert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/Analyze"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateCertificateHistoryRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	id int32
	xKeyfactorRequestedWith *string
	collectionId *int32
	xKeyfactorApiVersion *string
	queryPageReturned *int32
	queryReturnLimit *int32
	querySortField *string
	querySortAscending *int32
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateCertificateHistoryRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateCertificateHistoryRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The collection the certificate could be in.  Defaults to no collection.
func (r ApiCertificateCertificateHistoryRequest) CollectionId(collectionId int32) ApiCertificateCertificateHistoryRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateCertificateHistoryRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateCertificateHistoryRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// The current page within the result set to be returned
func (r ApiCertificateCertificateHistoryRequest) QueryPageReturned(queryPageReturned int32) ApiCertificateCertificateHistoryRequest {
	r.queryPageReturned = &queryPageReturned
	return r
}

// Maximum number of records to be returned in a single call
func (r ApiCertificateCertificateHistoryRequest) QueryReturnLimit(queryReturnLimit int32) ApiCertificateCertificateHistoryRequest {
	r.queryReturnLimit = &queryReturnLimit
	return r
}

// Field by which the results should be sorted (OperationStart, OperationEnd, UserName)
func (r ApiCertificateCertificateHistoryRequest) QuerySortField(querySortField string) ApiCertificateCertificateHistoryRequest {
	r.querySortField = &querySortField
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiCertificateCertificateHistoryRequest) QuerySortAscending(querySortAscending int32) ApiCertificateCertificateHistoryRequest {
	r.querySortAscending = &querySortAscending
	return r
}

func (r ApiCertificateCertificateHistoryRequest) Execute() ([]ModelsPKICertificateOperation, *http.Response, error) {
	return r.ApiService.CertificateCertificateHistoryExecute(r)
}

/*
CertificateCertificateHistory Gets the history of operations on a certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The Id of the certificate
 @return ApiCertificateCertificateHistoryRequest
*/
func (a *CertificateApiService) CertificateCertificateHistory(ctx context.Context, id int32) ApiCertificateCertificateHistoryRequest {
	return ApiCertificateCertificateHistoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ModelsPKICertificateOperation
func (a *CertificateApiService) CertificateCertificateHistoryExecute(r ApiCertificateCertificateHistoryRequest) ([]ModelsPKICertificateOperation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelsPKICertificateOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateCertificateHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/{id}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	if r.queryPageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "query.pageReturned", r.queryPageReturned, "")
	}
	if r.queryReturnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "query.returnLimit", r.queryReturnLimit, "")
	}
	if r.querySortField != nil {
		parameterAddToQuery(localVarQueryParams, "query.sortField", r.querySortField, "")
	}
	if r.querySortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "query.sortAscending", r.querySortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateCompareMetadataRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	certificateId *int32
	metadataFieldName *string
	value *string
	xKeyfactorRequestedWith *string
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Certificate identifier
func (r ApiCertificateCompareMetadataRequest) CertificateId(certificateId int32) ApiCertificateCompareMetadataRequest {
	r.certificateId = &certificateId
	return r
}

// Metadata field being compared
func (r ApiCertificateCompareMetadataRequest) MetadataFieldName(metadataFieldName string) ApiCertificateCompareMetadataRequest {
	r.metadataFieldName = &metadataFieldName
	return r
}

// Value to compare against
func (r ApiCertificateCompareMetadataRequest) Value(value string) ApiCertificateCompareMetadataRequest {
	r.value = &value
	return r
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateCompareMetadataRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateCompareMetadataRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificateCompareMetadataRequest) CollectionId(collectionId int32) ApiCertificateCompareMetadataRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateCompareMetadataRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateCompareMetadataRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateCompareMetadataRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.CertificateCompareMetadataExecute(r)
}

/*
CertificateCompareMetadata Compares the metadata value provided with the metadata value associated with the specified certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateCompareMetadataRequest
*/
func (a *CertificateApiService) CertificateCompareMetadata(ctx context.Context) ApiCertificateCompareMetadataRequest {
	return ApiCertificateCompareMetadataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *CertificateApiService) CertificateCompareMetadataExecute(r ApiCertificateCompareMetadataRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateCompareMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/Metadata/Compare"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.certificateId == nil {
		return localVarReturnValue, nil, reportError("certificateId is required and must be specified")
	}
	if r.metadataFieldName == nil {
		return localVarReturnValue, nil, reportError("metadataFieldName is required and must be specified")
	}
	if r.value == nil {
		return localVarReturnValue, nil, reportError("value is required and must be specified")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "certificateId", r.certificateId, "")
	parameterAddToQuery(localVarQueryParams, "metadataFieldName", r.metadataFieldName, "")
	parameterAddToQuery(localVarQueryParams, "value", r.value, "")
	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateDeleteByQueryRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	xKeyfactorRequestedWith *string
	sq *string
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateDeleteByQueryRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateDeleteByQueryRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Query by which certificates should be filtered for deletion
func (r ApiCertificateDeleteByQueryRequest) Sq(sq string) ApiCertificateDeleteByQueryRequest {
	r.sq = &sq
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificateDeleteByQueryRequest) CollectionId(collectionId int32) ApiCertificateDeleteByQueryRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateDeleteByQueryRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateDeleteByQueryRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateDeleteByQueryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateDeleteByQueryExecute(r)
}

/*
CertificateDeleteByQuery Deletes multiple persisted certificate entities selected by a given query

This will ignore individual delete failures, and continue processing the array.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateDeleteByQueryRequest
*/
func (a *CertificateApiService) CertificateDeleteByQuery(ctx context.Context) ApiCertificateDeleteByQueryRequest {
	return ApiCertificateDeleteByQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificateDeleteByQueryExecute(r ApiCertificateDeleteByQueryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateDeleteByQuery")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/Query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.sq == nil {
		return nil, reportError("sq is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.sq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateDeleteCertificateRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	id int32
	xKeyfactorRequestedWith *string
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateDeleteCertificateRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateDeleteCertificateRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificateDeleteCertificateRequest) CollectionId(collectionId int32) ApiCertificateDeleteCertificateRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateDeleteCertificateRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateDeleteCertificateRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateDeleteCertificateRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateDeleteCertificateExecute(r)
}

/*
CertificateDeleteCertificate Deletes a persisted certificate by its unique id as well as the stored private key (if present) associated with it

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Keyfactor identifier of the certificate record
 @return ApiCertificateDeleteCertificateRequest
*/
func (a *CertificateApiService) CertificateDeleteCertificate(ctx context.Context, id int32) ApiCertificateDeleteCertificateRequest {
	return ApiCertificateDeleteCertificateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificateDeleteCertificateExecute(r ApiCertificateDeleteCertificateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateDeleteCertificate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateDeleteCertificatesRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	xKeyfactorRequestedWith *string
	ids *[]int32
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateDeleteCertificatesRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateDeleteCertificatesRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The array of ids for certificate that are to be deleted
func (r ApiCertificateDeleteCertificatesRequest) Ids(ids []int32) ApiCertificateDeleteCertificatesRequest {
	r.ids = &ids
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificateDeleteCertificatesRequest) CollectionId(collectionId int32) ApiCertificateDeleteCertificatesRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateDeleteCertificatesRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateDeleteCertificatesRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateDeleteCertificatesRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateDeleteCertificatesExecute(r)
}

/*
CertificateDeleteCertificates Deletes multiple persisted certificates by their unique ids

This will ignore individual delete failures, and continue processing the array

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateDeleteCertificatesRequest
*/
func (a *CertificateApiService) CertificateDeleteCertificates(ctx context.Context) ApiCertificateDeleteCertificatesRequest {
	return ApiCertificateDeleteCertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificateDeleteCertificatesExecute(r ApiCertificateDeleteCertificatesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateDeleteCertificates")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.ids == nil {
		return nil, reportError("ids is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.ids
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateDeletePrivateKeys0Request struct {
	ctx context.Context
	ApiService *CertificateApiService
	xKeyfactorRequestedWith *string
	ids *[]int32
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateDeletePrivateKeys0Request) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateDeletePrivateKeys0Request {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Keyfactor identifiers of the cetficiates for which the associated private keys should be deleted
func (r ApiCertificateDeletePrivateKeys0Request) Ids(ids []int32) ApiCertificateDeletePrivateKeys0Request {
	r.ids = &ids
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificateDeletePrivateKeys0Request) CollectionId(collectionId int32) ApiCertificateDeletePrivateKeys0Request {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateDeletePrivateKeys0Request) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateDeletePrivateKeys0Request {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateDeletePrivateKeys0Request) Execute() (*http.Response, error) {
	return r.ApiService.CertificateDeletePrivateKeys0Execute(r)
}

/*
CertificateDeletePrivateKeys0 Deletes the persisted private keys of multiple certificates by the unique ids of the Certificates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateDeletePrivateKeys0Request
*/
func (a *CertificateApiService) CertificateDeletePrivateKeys0(ctx context.Context) ApiCertificateDeletePrivateKeys0Request {
	return ApiCertificateDeletePrivateKeys0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificateDeletePrivateKeys0Execute(r ApiCertificateDeletePrivateKeys0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateDeletePrivateKeys0")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/PrivateKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.ids == nil {
		return nil, reportError("ids is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.ids
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateDeletePrivateKeys1Request struct {
	ctx context.Context
	ApiService *CertificateApiService
	id int32
	xKeyfactorRequestedWith *string
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateDeletePrivateKeys1Request) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateDeletePrivateKeys1Request {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificateDeletePrivateKeys1Request) CollectionId(collectionId int32) ApiCertificateDeletePrivateKeys1Request {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateDeletePrivateKeys1Request) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateDeletePrivateKeys1Request {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateDeletePrivateKeys1Request) Execute() (*http.Response, error) {
	return r.ApiService.CertificateDeletePrivateKeys1Execute(r)
}

/*
CertificateDeletePrivateKeys1 Deletes the persisted private key of the certificate associated with the provided identifier

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Keyfactor identifier of the certificate for which the associated private key should be deleted
 @return ApiCertificateDeletePrivateKeys1Request
*/
func (a *CertificateApiService) CertificateDeletePrivateKeys1(ctx context.Context, id int32) ApiCertificateDeletePrivateKeys1Request {
	return ApiCertificateDeletePrivateKeys1Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificateDeletePrivateKeys1Execute(r ApiCertificateDeletePrivateKeys1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateDeletePrivateKeys1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/PrivateKey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateDownloadCertificateAsyncRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	xKeyfactorRequestedWith *string
	rq *ModelsCertificateDownloadRequest
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateDownloadCertificateAsyncRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateDownloadCertificateAsyncRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Query to filter the certificate to be recovered
func (r ApiCertificateDownloadCertificateAsyncRequest) Rq(rq ModelsCertificateDownloadRequest) ApiCertificateDownloadCertificateAsyncRequest {
	r.rq = &rq
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificateDownloadCertificateAsyncRequest) CollectionId(collectionId int32) ApiCertificateDownloadCertificateAsyncRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateDownloadCertificateAsyncRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateDownloadCertificateAsyncRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateDownloadCertificateAsyncRequest) Execute() (*ModelsCertificateDownloadResponse, *http.Response, error) {
	return r.ApiService.CertificateDownloadCertificateAsyncExecute(r)
}

/*
CertificateDownloadCertificateAsync Downloads the persisted certificate associated with the provided query

*NOTE: At least one of the following criteria must be provided:
1. Certificate ID
2. Thumbprint
3. Serial number AND Issuer DN (because Serial Number is CA-specific and so is not unique enough on its own)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateDownloadCertificateAsyncRequest
*/
func (a *CertificateApiService) CertificateDownloadCertificateAsync(ctx context.Context) ApiCertificateDownloadCertificateAsyncRequest {
	return ApiCertificateDownloadCertificateAsyncRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelsCertificateDownloadResponse
func (a *CertificateApiService) CertificateDownloadCertificateAsyncExecute(r ApiCertificateDownloadCertificateAsyncRequest) (*ModelsCertificateDownloadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsCertificateDownloadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateDownloadCertificateAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/Download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.rq == nil {
		return localVarReturnValue, nil, reportError("rq is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.rq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateGetCertificateRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	id int32
	xKeyfactorRequestedWith *string
	includeLocations *bool
	includeMetadata *bool
	collectionId *int32
	verbose *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateGetCertificateRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateGetCertificateRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Include locations data for the certificate to be returned
func (r ApiCertificateGetCertificateRequest) IncludeLocations(includeLocations bool) ApiCertificateGetCertificateRequest {
	r.includeLocations = &includeLocations
	return r
}

// Include metadata for the certificate to be returned
func (r ApiCertificateGetCertificateRequest) IncludeMetadata(includeMetadata bool) ApiCertificateGetCertificateRequest {
	r.includeMetadata = &includeMetadata
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificateGetCertificateRequest) CollectionId(collectionId int32) ApiCertificateGetCertificateRequest {
	r.collectionId = &collectionId
	return r
}

func (r ApiCertificateGetCertificateRequest) Verbose(verbose int32) ApiCertificateGetCertificateRequest {
	r.verbose = &verbose
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateGetCertificateRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateGetCertificateRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateGetCertificateRequest) Execute() (*ModelsCertificateRetrievalResponse, *http.Response, error) {
	return r.ApiService.CertificateGetCertificateExecute(r)
}

/*
CertificateGetCertificate Returns a single certificate that matches the id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Keyfactor certificate identifier
 @return ApiCertificateGetCertificateRequest
*/
func (a *CertificateApiService) CertificateGetCertificate(ctx context.Context, id int32) ApiCertificateGetCertificateRequest {
	return ApiCertificateGetCertificateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelsCertificateRetrievalResponse
func (a *CertificateApiService) CertificateGetCertificateExecute(r ApiCertificateGetCertificateRequest) (*ModelsCertificateRetrievalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsCertificateRetrievalResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateGetCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.includeLocations != nil {
		parameterAddToQuery(localVarQueryParams, "includeLocations", r.includeLocations, "")
	}
	if r.includeMetadata != nil {
		parameterAddToQuery(localVarQueryParams, "includeMetadata", r.includeMetadata, "")
	}
	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	if r.verbose != nil {
		parameterAddToQuery(localVarQueryParams, "verbose", r.verbose, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateGetCertificateLocationsRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	id int32
	xKeyfactorRequestedWith *string
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateGetCertificateLocationsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateGetCertificateLocationsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificateGetCertificateLocationsRequest) CollectionId(collectionId int32) ApiCertificateGetCertificateLocationsRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateGetCertificateLocationsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateGetCertificateLocationsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateGetCertificateLocationsRequest) Execute() (*KeyfactorApiModelsCertificatesCertificateLocationsResponse, *http.Response, error) {
	return r.ApiService.CertificateGetCertificateLocationsExecute(r)
}

/*
CertificateGetCertificateLocations Returns a list of locations the certificate is in

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Keyfactor certificate identifier
 @return ApiCertificateGetCertificateLocationsRequest
*/
func (a *CertificateApiService) CertificateGetCertificateLocations(ctx context.Context, id int32) ApiCertificateGetCertificateLocationsRequest {
	return ApiCertificateGetCertificateLocationsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return KeyfactorApiModelsCertificatesCertificateLocationsResponse
func (a *CertificateApiService) CertificateGetCertificateLocationsExecute(r ApiCertificateGetCertificateLocationsRequest) (*KeyfactorApiModelsCertificatesCertificateLocationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeyfactorApiModelsCertificatesCertificateLocationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateGetCertificateLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/Locations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateGetCertificateSecurityRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	id int32
	xKeyfactorRequestedWith *string
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateGetCertificateSecurityRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateGetCertificateSecurityRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The Id of the collection the certificate belongs in. Defaults to no collection
func (r ApiCertificateGetCertificateSecurityRequest) CollectionId(collectionId int32) ApiCertificateGetCertificateSecurityRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateGetCertificateSecurityRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateGetCertificateSecurityRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateGetCertificateSecurityRequest) Execute() (*ModelsSecurityCertificatePermissions, *http.Response, error) {
	return r.ApiService.CertificateGetCertificateSecurityExecute(r)
}

/*
CertificateGetCertificateSecurity Gets the list of Security Identities and which permissions they have on the given certificate.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The Id of the certificate permissions are being checked on
 @return ApiCertificateGetCertificateSecurityRequest
*/
func (a *CertificateApiService) CertificateGetCertificateSecurity(ctx context.Context, id int32) ApiCertificateGetCertificateSecurityRequest {
	return ApiCertificateGetCertificateSecurityRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelsSecurityCertificatePermissions
func (a *CertificateApiService) CertificateGetCertificateSecurityExecute(r ApiCertificateGetCertificateSecurityRequest) (*ModelsSecurityCertificatePermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsSecurityCertificatePermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateGetCertificateSecurity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/{id}/Security"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateIdentityAuditRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	id int32
	xKeyfactorRequestedWith *string
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateIdentityAuditRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateIdentityAuditRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// An optional parameter for the collectin Id the certificate is in.  Defaults to no collection
func (r ApiCertificateIdentityAuditRequest) CollectionId(collectionId int32) ApiCertificateIdentityAuditRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateIdentityAuditRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateIdentityAuditRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateIdentityAuditRequest) Execute() ([]KeyfactorApiModelsCertificatesCertificateIdentityAuditResponse, *http.Response, error) {
	return r.ApiService.CertificateIdentityAuditExecute(r)
}

/*
CertificateIdentityAudit Audit identity permissions for certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The Id of the certificate being checked
 @return ApiCertificateIdentityAuditRequest
*/
func (a *CertificateApiService) CertificateIdentityAudit(ctx context.Context, id int32) ApiCertificateIdentityAuditRequest {
	return ApiCertificateIdentityAuditRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsCertificatesCertificateIdentityAuditResponse
func (a *CertificateApiService) CertificateIdentityAuditExecute(r ApiCertificateIdentityAuditRequest) ([]KeyfactorApiModelsCertificatesCertificateIdentityAuditResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsCertificatesCertificateIdentityAuditResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateIdentityAudit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/IdentityAudit/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatePostImportCertificateRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	xKeyfactorRequestedWith *string
	req *ModelsCertificateImportRequestModel
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatePostImportCertificateRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatePostImportCertificateRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Request containing the base 64 encoded string and related certificate information, such as certificate stores, metadata, and password
func (r ApiCertificatePostImportCertificateRequest) Req(req ModelsCertificateImportRequestModel) ApiCertificatePostImportCertificateRequest {
	r.req = &req
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatePostImportCertificateRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatePostImportCertificateRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificatePostImportCertificateRequest) Execute() (*ModelsCertificateImportResponseModel, *http.Response, error) {
	return r.ApiService.CertificatePostImportCertificateExecute(r)
}

/*
CertificatePostImportCertificate Imports the provided certificate into the Keyfactor instance, including any provided associated data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificatePostImportCertificateRequest
*/
func (a *CertificateApiService) CertificatePostImportCertificate(ctx context.Context) ApiCertificatePostImportCertificateRequest {
	return ApiCertificatePostImportCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelsCertificateImportResponseModel
func (a *CertificateApiService) CertificatePostImportCertificateExecute(r ApiCertificatePostImportCertificateRequest) (*ModelsCertificateImportResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsCertificateImportResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificatePostImportCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/Import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.req == nil {
		return localVarReturnValue, nil, reportError("req is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.req
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateQueryCertificatesRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	xKeyfactorRequestedWith *string
	collectionId *int32
	includeLocations *bool
	includeMetadata *bool
	includeHasPrivateKey *bool
	verbose *int32
	xKeyfactorApiVersion *string
	pqQueryString *string
	pqPageReturned *int32
	pqReturnLimit *int32
	pqSortField *string
	pqSortAscending *int32
	pqIncludeRevoked *bool
	pqIncludeExpired *bool
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateQueryCertificatesRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateQueryCertificatesRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificateQueryCertificatesRequest) CollectionId(collectionId int32) ApiCertificateQueryCertificatesRequest {
	r.collectionId = &collectionId
	return r
}

// Include locations data for the certificates to be returned
func (r ApiCertificateQueryCertificatesRequest) IncludeLocations(includeLocations bool) ApiCertificateQueryCertificatesRequest {
	r.includeLocations = &includeLocations
	return r
}

// Include metadata for the certificates to be returned
func (r ApiCertificateQueryCertificatesRequest) IncludeMetadata(includeMetadata bool) ApiCertificateQueryCertificatesRequest {
	r.includeMetadata = &includeMetadata
	return r
}

// Include whether the certificates to be returned have private keys stored in the Keyfactor database
func (r ApiCertificateQueryCertificatesRequest) IncludeHasPrivateKey(includeHasPrivateKey bool) ApiCertificateQueryCertificatesRequest {
	r.includeHasPrivateKey = &includeHasPrivateKey
	return r
}

func (r ApiCertificateQueryCertificatesRequest) Verbose(verbose int32) ApiCertificateQueryCertificatesRequest {
	r.verbose = &verbose
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateQueryCertificatesRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateQueryCertificatesRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Contents of the query (ex: field1 -eq value1 AND field2 -gt value2)
func (r ApiCertificateQueryCertificatesRequest) PqQueryString(pqQueryString string) ApiCertificateQueryCertificatesRequest {
	r.pqQueryString = &pqQueryString
	return r
}

// The current page within the result set to be returned
func (r ApiCertificateQueryCertificatesRequest) PqPageReturned(pqPageReturned int32) ApiCertificateQueryCertificatesRequest {
	r.pqPageReturned = &pqPageReturned
	return r
}

// Maximum number of records to be returned in a single call
func (r ApiCertificateQueryCertificatesRequest) PqReturnLimit(pqReturnLimit int32) ApiCertificateQueryCertificatesRequest {
	r.pqReturnLimit = &pqReturnLimit
	return r
}

// Field by which the results should be sorted (view results via Management Portal for sortable columns)
func (r ApiCertificateQueryCertificatesRequest) PqSortField(pqSortField string) ApiCertificateQueryCertificatesRequest {
	r.pqSortField = &pqSortField
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiCertificateQueryCertificatesRequest) PqSortAscending(pqSortAscending int32) ApiCertificateQueryCertificatesRequest {
	r.pqSortAscending = &pqSortAscending
	return r
}

// Select &#39;true&#39; to include revoked certificates in the results
func (r ApiCertificateQueryCertificatesRequest) PqIncludeRevoked(pqIncludeRevoked bool) ApiCertificateQueryCertificatesRequest {
	r.pqIncludeRevoked = &pqIncludeRevoked
	return r
}

// Select &#39;true&#39; to include expired certificates in the results
func (r ApiCertificateQueryCertificatesRequest) PqIncludeExpired(pqIncludeExpired bool) ApiCertificateQueryCertificatesRequest {
	r.pqIncludeExpired = &pqIncludeExpired
	return r
}

func (r ApiCertificateQueryCertificatesRequest) Execute() ([]ModelsCertificateRetrievalResponse, *http.Response, error) {
	return r.ApiService.CertificateQueryCertificatesExecute(r)
}

/*
CertificateQueryCertificates Returns all certificates according to the provided filter and output parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateQueryCertificatesRequest
*/
func (a *CertificateApiService) CertificateQueryCertificates(ctx context.Context) ApiCertificateQueryCertificatesRequest {
	return ApiCertificateQueryCertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelsCertificateRetrievalResponse
func (a *CertificateApiService) CertificateQueryCertificatesExecute(r ApiCertificateQueryCertificatesRequest) ([]ModelsCertificateRetrievalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelsCertificateRetrievalResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateQueryCertificates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	if r.includeLocations != nil {
		parameterAddToQuery(localVarQueryParams, "includeLocations", r.includeLocations, "")
	}
	if r.includeMetadata != nil {
		parameterAddToQuery(localVarQueryParams, "includeMetadata", r.includeMetadata, "")
	}
	if r.includeHasPrivateKey != nil {
		parameterAddToQuery(localVarQueryParams, "includeHasPrivateKey", r.includeHasPrivateKey, "")
	}
	if r.verbose != nil {
		parameterAddToQuery(localVarQueryParams, "verbose", r.verbose, "")
	}
	if r.pqQueryString != nil {
		parameterAddToQuery(localVarQueryParams, "pq.queryString", r.pqQueryString, "")
	}
	if r.pqPageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "pq.pageReturned", r.pqPageReturned, "")
	}
	if r.pqReturnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "pq.returnLimit", r.pqReturnLimit, "")
	}
	if r.pqSortField != nil {
		parameterAddToQuery(localVarQueryParams, "pq.sortField", r.pqSortField, "")
	}
	if r.pqSortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "pq.sortAscending", r.pqSortAscending, "")
	}
	if r.pqIncludeRevoked != nil {
		parameterAddToQuery(localVarQueryParams, "pq.includeRevoked", r.pqIncludeRevoked, "")
	}
	if r.pqIncludeExpired != nil {
		parameterAddToQuery(localVarQueryParams, "pq.includeExpired", r.pqIncludeExpired, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateRecoverCertificateAsyncRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	xCertificateformat *string
	xKeyfactorRequestedWith *string
	rq *ModelsCertificateRecoveryRequest
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Desired format [PFX, PEM]
func (r ApiCertificateRecoverCertificateAsyncRequest) XCertificateformat(xCertificateformat string) ApiCertificateRecoverCertificateAsyncRequest {
	r.xCertificateformat = &xCertificateformat
	return r
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateRecoverCertificateAsyncRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateRecoverCertificateAsyncRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Query to filter the certificate to be recovered
func (r ApiCertificateRecoverCertificateAsyncRequest) Rq(rq ModelsCertificateRecoveryRequest) ApiCertificateRecoverCertificateAsyncRequest {
	r.rq = &rq
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificateRecoverCertificateAsyncRequest) CollectionId(collectionId int32) ApiCertificateRecoverCertificateAsyncRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateRecoverCertificateAsyncRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateRecoverCertificateAsyncRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateRecoverCertificateAsyncRequest) Execute() (*ModelsRecoveryResponse, *http.Response, error) {
	return r.ApiService.CertificateRecoverCertificateAsyncExecute(r)
}

/*
CertificateRecoverCertificateAsync Recovers the persisted certificate associated with the provided query

*NOTE: At least one of the following criteria must be provided:
1. Certificate ID
2. Thumbprint
3. Serial number AND Issuer DN (because Serial Number is CA-specific and so is not unique enough on its own)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateRecoverCertificateAsyncRequest
*/
func (a *CertificateApiService) CertificateRecoverCertificateAsync(ctx context.Context) ApiCertificateRecoverCertificateAsyncRequest {
	return ApiCertificateRecoverCertificateAsyncRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelsRecoveryResponse
func (a *CertificateApiService) CertificateRecoverCertificateAsyncExecute(r ApiCertificateRecoverCertificateAsyncRequest) (*ModelsRecoveryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsRecoveryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateRecoverCertificateAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/Recover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCertificateformat == nil {
		return localVarReturnValue, nil, reportError("xCertificateformat is required and must be specified")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.rq == nil {
		return localVarReturnValue, nil, reportError("rq is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarQueryParams, "x-certificateformat", r.xCertificateformat, "")
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.rq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateRevokeRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	xKeyfactorRequestedWith *string
	request *ModelsRevokeCertificateRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateRevokeRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateRevokeRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Contains the Keyfactor certificate identifiers and revocation data
func (r ApiCertificateRevokeRequest) Request(request ModelsRevokeCertificateRequest) ApiCertificateRevokeRequest {
	r.request = &request
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateRevokeRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateRevokeRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateRevokeRequest) Execute() (*ModelsRevocationRevocationResponse, *http.Response, error) {
	return r.ApiService.CertificateRevokeExecute(r)
}

/*
CertificateRevoke Revokes the certificates associated with the provided identifiers and associates the provided data with the revocation

### Revocation Reason Codes for Microsoft CA ###
| Value             | Description               |
|-------------------|---------------------------|
| -1                | Remove from hold          |
| 0                 | Unspecified               |
| 1                 | Key compromised           |
| 2                 | CA compromised            |
| 3                 | Affiliation changed       |
| 4                 | Superceded                |
| 5                 | Cessation of operation    |
| 6                 | Certificate hold          |
| 7                 | Remove from CRL           |
| 999               | Unknown                   |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateRevokeRequest
*/
func (a *CertificateApiService) CertificateRevoke(ctx context.Context) ApiCertificateRevokeRequest {
	return ApiCertificateRevokeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelsRevocationRevocationResponse
func (a *CertificateApiService) CertificateRevokeExecute(r ApiCertificateRevokeRequest) (*ModelsRevocationRevocationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsRevocationRevocationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateRevoke")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/Revoke"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateRevokeAllRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	xKeyfactorRequestedWith *string
	request *ModelsRevokeAllCertificatesRequest
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateRevokeAllRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateRevokeAllRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Contains the Keyfactor Query and revocation data
func (r ApiCertificateRevokeAllRequest) Request(request ModelsRevokeAllCertificatesRequest) ApiCertificateRevokeAllRequest {
	r.request = &request
	return r
}

// A collection Id to be used for permissions and part of the query to revoke certificates
func (r ApiCertificateRevokeAllRequest) CollectionId(collectionId int32) ApiCertificateRevokeAllRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateRevokeAllRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateRevokeAllRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateRevokeAllRequest) Execute() (*ModelsRevocationRevocationResponse, *http.Response, error) {
	return r.ApiService.CertificateRevokeAllExecute(r)
}

/*
CertificateRevokeAll Revokes the certificates associated with the provided query and Collection Id and associates the provided data with the revocation

### Revocation Reason Codes for Microsoft CA ###
| Value             | Description              |
|-------------------|--------------------------|
| -1                | Remove from hold         |
| 0                 | Unspecified              |
| 1                 | Key compromised          |
| 2                 | CA compromised           |
| 3                 | Affiliation changed      |
| 4                 | Superceded               |
| 5                 | Cessation of operation   |
| 6                 | Certificate hold         |
| 7                 | Remove from CRL          |
| 999               | Unknown                  |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateRevokeAllRequest
*/
func (a *CertificateApiService) CertificateRevokeAll(ctx context.Context) ApiCertificateRevokeAllRequest {
	return ApiCertificateRevokeAllRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelsRevocationRevocationResponse
func (a *CertificateApiService) CertificateRevokeAllExecute(r ApiCertificateRevokeAllRequest) (*ModelsRevocationRevocationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsRevocationRevocationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateRevokeAll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/RevokeAll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateUpdateAllMetadataRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	xKeyfactorRequestedWith *string
	metadataUpdate *ModelsMetadataAllUpdateRequest
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateUpdateAllMetadataRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateUpdateAllMetadataRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Contains the Keyfactor certificate identifier and the metadata to be updated
func (r ApiCertificateUpdateAllMetadataRequest) MetadataUpdate(metadataUpdate ModelsMetadataAllUpdateRequest) ApiCertificateUpdateAllMetadataRequest {
	r.metadataUpdate = &metadataUpdate
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificateUpdateAllMetadataRequest) CollectionId(collectionId int32) ApiCertificateUpdateAllMetadataRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateUpdateAllMetadataRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateUpdateAllMetadataRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateUpdateAllMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateUpdateAllMetadataExecute(r)
}

/*
CertificateUpdateAllMetadata Updates the metadata for certificates associated with the certificate identifiers or query provided

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateUpdateAllMetadataRequest
*/
func (a *CertificateApiService) CertificateUpdateAllMetadata(ctx context.Context) ApiCertificateUpdateAllMetadataRequest {
	return ApiCertificateUpdateAllMetadataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificateUpdateAllMetadataExecute(r ApiCertificateUpdateAllMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateUpdateAllMetadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/Metadata/All"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.metadataUpdate == nil {
		return nil, reportError("metadataUpdate is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.metadataUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateUpdateMetadataRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	xKeyfactorRequestedWith *string
	metadataUpdate *ModelsMetadataUpdateRequest
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateUpdateMetadataRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateUpdateMetadataRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Contains the Keyfactor certificate identifier and the metadata to be updated
func (r ApiCertificateUpdateMetadataRequest) MetadataUpdate(metadataUpdate ModelsMetadataUpdateRequest) ApiCertificateUpdateMetadataRequest {
	r.metadataUpdate = &metadataUpdate
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificateUpdateMetadataRequest) CollectionId(collectionId int32) ApiCertificateUpdateMetadataRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateUpdateMetadataRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateUpdateMetadataRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateUpdateMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateUpdateMetadataExecute(r)
}

/*
CertificateUpdateMetadata Updates the metadata for the certificate associated with the identifier provided

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCertificateUpdateMetadataRequest
*/
func (a *CertificateApiService) CertificateUpdateMetadata(ctx context.Context) ApiCertificateUpdateMetadataRequest {
	return ApiCertificateUpdateMetadataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificateUpdateMetadataExecute(r ApiCertificateUpdateMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateUpdateMetadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/Metadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.metadataUpdate == nil {
		return nil, reportError("metadataUpdate is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.metadataUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateValidateCertificateRequest struct {
	ctx context.Context
	ApiService *CertificateApiService
	id int32
	xKeyfactorRequestedWith *string
	collectionId *int32
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateValidateCertificateRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateValidateCertificateRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// An optional parameter for the collectin Id the certificate is in.  Defaults to no collection
func (r ApiCertificateValidateCertificateRequest) CollectionId(collectionId int32) ApiCertificateValidateCertificateRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateValidateCertificateRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateValidateCertificateRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateValidateCertificateRequest) Execute() (*ModelsCertificateValidationResponse, *http.Response, error) {
	return r.ApiService.CertificateValidateCertificateExecute(r)
}

/*
CertificateValidateCertificate Validates the certificate chain can be built.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The Id of the certificate being checked
 @return ApiCertificateValidateCertificateRequest
*/
func (a *CertificateApiService) CertificateValidateCertificate(ctx context.Context, id int32) ApiCertificateValidateCertificateRequest {
	return ApiCertificateValidateCertificateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ModelsCertificateValidationResponse
func (a *CertificateApiService) CertificateValidateCertificateExecute(r ApiCertificateValidateCertificateRequest) (*ModelsCertificateValidationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelsCertificateValidationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificateApiService.CertificateValidateCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Certificates/{id}/Validate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
