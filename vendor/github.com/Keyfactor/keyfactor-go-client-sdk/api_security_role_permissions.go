/*
Keyfactor-v1

This reference serves to document REST-based methods to manage and integrate with Keyfactor. In addition, an embedded interface allows for the execution of calls against the current Keyfactor API instance.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keyfactor_command_client_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// SecurityRolePermissionsApiService SecurityRolePermissionsApi service
type SecurityRolePermissionsApiService service

type ApiSecurityRolePermissionsAddCollectionPermissionsRequest struct {
	ctx context.Context
	ApiService *SecurityRolePermissionsApiService
	id int32
	xKeyfactorRequestedWith *string
	collectionPermissions *[]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolePermissionsAddCollectionPermissionsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolePermissionsAddCollectionPermissionsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Collections permissions
func (r ApiSecurityRolePermissionsAddCollectionPermissionsRequest) CollectionPermissions(collectionPermissions []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionRequest) ApiSecurityRolePermissionsAddCollectionPermissionsRequest {
	r.collectionPermissions = &collectionPermissions
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolePermissionsAddCollectionPermissionsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolePermissionsAddCollectionPermissionsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolePermissionsAddCollectionPermissionsRequest) Execute() ([]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionResponse, *http.Response, error) {
	return r.ApiService.SecurityRolePermissionsAddCollectionPermissionsExecute(r)
}

/*
SecurityRolePermissionsAddCollectionPermissions Adds collection permissions to the security role that matches the id.

### Valid Permissions ###
| Permission    | Permission Display Name   |
|---------------|---------------------------|
| Read          | Read                      |
| EditMetadata  | Edit Metadata             |
| Recover       | Download with Private Key |
| Revoke        | Revoke                    |
| Delete        | Delete                    |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Security role identifier
 @return ApiSecurityRolePermissionsAddCollectionPermissionsRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsAddCollectionPermissions(ctx context.Context, id int32) ApiSecurityRolePermissionsAddCollectionPermissionsRequest {
	return ApiSecurityRolePermissionsAddCollectionPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionResponse
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsAddCollectionPermissionsExecute(r ApiSecurityRolePermissionsAddCollectionPermissionsRequest) ([]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityRolePermissionsApiService.SecurityRolePermissionsAddCollectionPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Security/Roles/{id}/Permissions/Collections"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.collectionPermissions == nil {
		return localVarReturnValue, nil, reportError("collectionPermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.collectionPermissions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolePermissionsAddContainerPermissionsRequest struct {
	ctx context.Context
	ApiService *SecurityRolePermissionsApiService
	id int32
	xKeyfactorRequestedWith *string
	containerPermissions *[]KeyfactorApiModelsSecurityRolesContainerPermissionRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolePermissionsAddContainerPermissionsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolePermissionsAddContainerPermissionsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Container permissions
func (r ApiSecurityRolePermissionsAddContainerPermissionsRequest) ContainerPermissions(containerPermissions []KeyfactorApiModelsSecurityRolesContainerPermissionRequest) ApiSecurityRolePermissionsAddContainerPermissionsRequest {
	r.containerPermissions = &containerPermissions
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolePermissionsAddContainerPermissionsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolePermissionsAddContainerPermissionsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolePermissionsAddContainerPermissionsRequest) Execute() ([]KeyfactorApiModelsSecurityRolesContainerPermissionResponse, *http.Response, error) {
	return r.ApiService.SecurityRolePermissionsAddContainerPermissionsExecute(r)
}

/*
SecurityRolePermissionsAddContainerPermissions Adds container permissions to the security role that matches the id.

### Valid Permissions ###
| Permission    | Requisite Permissions |
|---------------|-----------------------|
| Read          |                       |
| Schedule      | Read                  |
| Modify        | Read, Schedule        |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Security role identifier
 @return ApiSecurityRolePermissionsAddContainerPermissionsRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsAddContainerPermissions(ctx context.Context, id int32) ApiSecurityRolePermissionsAddContainerPermissionsRequest {
	return ApiSecurityRolePermissionsAddContainerPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsSecurityRolesContainerPermissionResponse
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsAddContainerPermissionsExecute(r ApiSecurityRolePermissionsAddContainerPermissionsRequest) ([]KeyfactorApiModelsSecurityRolesContainerPermissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsSecurityRolesContainerPermissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityRolePermissionsApiService.SecurityRolePermissionsAddContainerPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Security/Roles/{id}/Permissions/Containers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.containerPermissions == nil {
		return localVarReturnValue, nil, reportError("containerPermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.containerPermissions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolePermissionsAddGlobalPermissionsRequest struct {
	ctx context.Context
	ApiService *SecurityRolePermissionsApiService
	id int32
	xKeyfactorRequestedWith *string
	globalPermissions *[]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolePermissionsAddGlobalPermissionsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolePermissionsAddGlobalPermissionsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Global permissions
func (r ApiSecurityRolePermissionsAddGlobalPermissionsRequest) GlobalPermissions(globalPermissions []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionRequest) ApiSecurityRolePermissionsAddGlobalPermissionsRequest {
	r.globalPermissions = &globalPermissions
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolePermissionsAddGlobalPermissionsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolePermissionsAddGlobalPermissionsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolePermissionsAddGlobalPermissionsRequest) Execute() ([]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionResponse, *http.Response, error) {
	return r.ApiService.SecurityRolePermissionsAddGlobalPermissionsExecute(r)
}

/*
SecurityRolePermissionsAddGlobalPermissions Adds global permissions to the security role that matches the id.

### Valid Global Permissions ###
| Area                          | Permission        |
|-------------------------------|-------------------|
| AdminPortal                   | Read              |
| AgentAutoRegistration         | Read              |
| AgentAutoRegistration         | Modify            |
| AgentManagement               | Read              |
| AgentManagement               | Modify            |
| API                           | Read              |
| ApplicationSettings           | Read              |
| ApplicationSettings           | Modify            |
| Auditing                      | Read              |
| CertificateCollections        | Modify            |
| CertificateEnrollment         | EnrollPFX         |
| CertificateEnrollment         | EnrollCSR         |
| CertificateEnrollment         | CsrGeneration     |
| CertificateEnrollment         | PendingCsr        |
| CertificateMetadataTypes      | Read              |
| CertificateMetadataTypes      | Modify            |
| Certificates                  | Read              |
| Certificates                  | EditMetadata      |
| Certificates                  | Import            |
| Certificates                  | Recover           |
| Certificates                  | Revoke            |
| Certificates                  | Delete            |
| Certificates                  | ImportPrivateKey  |
| CertificateStoreManagement    | Read              |
| CertificateStoreManagement    | Schedule          |
| CertificateStoreManagement    | Modify            |
| Dashboard                     | Read              |
| Dashboard                     | RiskHeader        |
| EventHandlerRegistration      | Read              |
| EventHandlerRegistration      | Modify            |
| MacAutoEnrollManagement       | Read              |
| MacAutoEnrollManagement       | Modify            |
| Monitoring                    | Read              |
| Monitoring                    | Modify            |
| Monitoring                    | Test              |
| PkiManagement                 | Read              |
| PkiManagement                 | Modify            |
| PrivilegedAccessManagement    | Read              |
| PrivilegedAccessManagement    | Modify            |
| Reports                       | Read              |
| Reports                       | Modify            |
| SecuritySettings              | Read              |
| SecuritySettings              | Modify            |
| SSH                           | User              |
| SSH                           | ServerAdmin       |
| SSH                           | EnterpriseAdmin   |
| SslManagement                 | Read              |
| SslManagement                 | Modify            |
| SystemSettings                | Read              |
| SystemSettings                | Modify            |
| WorkflowDefinitions           | Read              |
| WorkflowDefinitions           | Modify            |
| WorkflowInstances             | ReadAll           |
| WorkflowInstances             | ReadAssignedToMe  |
| WorkflowInstances             | ReadMy            |
| WorkflowInstances             | Manage            |
| WorkflowManagement            | Read              |
| WorkflowManagement            | Modify            |
| WorkflowManagement            | Test              |
| WorkflowManagement            | Participate       |
| WorkflowManagement            | Manage            |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Security role identifier
 @return ApiSecurityRolePermissionsAddGlobalPermissionsRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsAddGlobalPermissions(ctx context.Context, id int32) ApiSecurityRolePermissionsAddGlobalPermissionsRequest {
	return ApiSecurityRolePermissionsAddGlobalPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionResponse
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsAddGlobalPermissionsExecute(r ApiSecurityRolePermissionsAddGlobalPermissionsRequest) ([]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityRolePermissionsApiService.SecurityRolePermissionsAddGlobalPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Security/Roles/{id}/Permissions/Global"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.globalPermissions == nil {
		return localVarReturnValue, nil, reportError("globalPermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.globalPermissions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolePermissionsGetCollectionPermissionsForRoleRequest struct {
	ctx context.Context
	ApiService *SecurityRolePermissionsApiService
	id int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolePermissionsGetCollectionPermissionsForRoleRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolePermissionsGetCollectionPermissionsForRoleRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolePermissionsGetCollectionPermissionsForRoleRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolePermissionsGetCollectionPermissionsForRoleRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolePermissionsGetCollectionPermissionsForRoleRequest) Execute() ([]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionResponse, *http.Response, error) {
	return r.ApiService.SecurityRolePermissionsGetCollectionPermissionsForRoleExecute(r)
}

/*
SecurityRolePermissionsGetCollectionPermissionsForRole Returns all collection permissions associated with the security role that matches the id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Security role identifier
 @return ApiSecurityRolePermissionsGetCollectionPermissionsForRoleRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsGetCollectionPermissionsForRole(ctx context.Context, id int32) ApiSecurityRolePermissionsGetCollectionPermissionsForRoleRequest {
	return ApiSecurityRolePermissionsGetCollectionPermissionsForRoleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionResponse
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsGetCollectionPermissionsForRoleExecute(r ApiSecurityRolePermissionsGetCollectionPermissionsForRoleRequest) ([]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityRolePermissionsApiService.SecurityRolePermissionsGetCollectionPermissionsForRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Security/Roles/{id}/Permissions/Collections"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolePermissionsGetContainerPermissionsForRoleRequest struct {
	ctx context.Context
	ApiService *SecurityRolePermissionsApiService
	id int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolePermissionsGetContainerPermissionsForRoleRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolePermissionsGetContainerPermissionsForRoleRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolePermissionsGetContainerPermissionsForRoleRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolePermissionsGetContainerPermissionsForRoleRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolePermissionsGetContainerPermissionsForRoleRequest) Execute() ([]KeyfactorApiModelsSecurityRolesContainerPermissionResponse, *http.Response, error) {
	return r.ApiService.SecurityRolePermissionsGetContainerPermissionsForRoleExecute(r)
}

/*
SecurityRolePermissionsGetContainerPermissionsForRole Returns all container permissions associated with the security role that matches the id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Security role identifier
 @return ApiSecurityRolePermissionsGetContainerPermissionsForRoleRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsGetContainerPermissionsForRole(ctx context.Context, id int32) ApiSecurityRolePermissionsGetContainerPermissionsForRoleRequest {
	return ApiSecurityRolePermissionsGetContainerPermissionsForRoleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsSecurityRolesContainerPermissionResponse
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsGetContainerPermissionsForRoleExecute(r ApiSecurityRolePermissionsGetContainerPermissionsForRoleRequest) ([]KeyfactorApiModelsSecurityRolesContainerPermissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsSecurityRolesContainerPermissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityRolePermissionsApiService.SecurityRolePermissionsGetContainerPermissionsForRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Security/Roles/{id}/Permissions/Containers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolePermissionsGetGlobalPermissionsForRoleRequest struct {
	ctx context.Context
	ApiService *SecurityRolePermissionsApiService
	id int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolePermissionsGetGlobalPermissionsForRoleRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolePermissionsGetGlobalPermissionsForRoleRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolePermissionsGetGlobalPermissionsForRoleRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolePermissionsGetGlobalPermissionsForRoleRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolePermissionsGetGlobalPermissionsForRoleRequest) Execute() ([]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionResponse, *http.Response, error) {
	return r.ApiService.SecurityRolePermissionsGetGlobalPermissionsForRoleExecute(r)
}

/*
SecurityRolePermissionsGetGlobalPermissionsForRole Returns all global permissions associated with the security role that matches the id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Security role identifier
 @return ApiSecurityRolePermissionsGetGlobalPermissionsForRoleRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsGetGlobalPermissionsForRole(ctx context.Context, id int32) ApiSecurityRolePermissionsGetGlobalPermissionsForRoleRequest {
	return ApiSecurityRolePermissionsGetGlobalPermissionsForRoleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionResponse
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsGetGlobalPermissionsForRoleExecute(r ApiSecurityRolePermissionsGetGlobalPermissionsForRoleRequest) ([]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityRolePermissionsApiService.SecurityRolePermissionsGetGlobalPermissionsForRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Security/Roles/{id}/Permissions/Global"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolePermissionsGetPermissionsForRoleRequest struct {
	ctx context.Context
	ApiService *SecurityRolePermissionsApiService
	id int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolePermissionsGetPermissionsForRoleRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolePermissionsGetPermissionsForRoleRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolePermissionsGetPermissionsForRoleRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolePermissionsGetPermissionsForRoleRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolePermissionsGetPermissionsForRoleRequest) Execute() ([]KeyfactorApiModelsSecurityRolesAreaPermissionResponse, *http.Response, error) {
	return r.ApiService.SecurityRolePermissionsGetPermissionsForRoleExecute(r)
}

/*
SecurityRolePermissionsGetPermissionsForRole Returns all permissions associated with the security role that matches the id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Security role identifier
 @return ApiSecurityRolePermissionsGetPermissionsForRoleRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsGetPermissionsForRole(ctx context.Context, id int32) ApiSecurityRolePermissionsGetPermissionsForRoleRequest {
	return ApiSecurityRolePermissionsGetPermissionsForRoleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsSecurityRolesAreaPermissionResponse
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsGetPermissionsForRoleExecute(r ApiSecurityRolePermissionsGetPermissionsForRoleRequest) ([]KeyfactorApiModelsSecurityRolesAreaPermissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsSecurityRolesAreaPermissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityRolePermissionsApiService.SecurityRolePermissionsGetPermissionsForRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Security/Roles/{id}/Permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolePermissionsSetCollectionPermissionsRequest struct {
	ctx context.Context
	ApiService *SecurityRolePermissionsApiService
	id int32
	xKeyfactorRequestedWith *string
	collectionPermissions *[]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolePermissionsSetCollectionPermissionsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolePermissionsSetCollectionPermissionsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Collections permissions
func (r ApiSecurityRolePermissionsSetCollectionPermissionsRequest) CollectionPermissions(collectionPermissions []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionRequest) ApiSecurityRolePermissionsSetCollectionPermissionsRequest {
	r.collectionPermissions = &collectionPermissions
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolePermissionsSetCollectionPermissionsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolePermissionsSetCollectionPermissionsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolePermissionsSetCollectionPermissionsRequest) Execute() ([]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionResponse, *http.Response, error) {
	return r.ApiService.SecurityRolePermissionsSetCollectionPermissionsExecute(r)
}

/*
SecurityRolePermissionsSetCollectionPermissions Sets collection permissions to the security role that matches the id.

### Valid Permissions ###
| Permission    | Permission Display Name   |
|---------------|---------------------------|
| Read          | Read                      |
| EditMetadata  | Edit Metadata             |
| Recover       | Download with Private Key |
| Revoke        | Revoke                    |
| Delete        | Delete                    |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Security role identifier
 @return ApiSecurityRolePermissionsSetCollectionPermissionsRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsSetCollectionPermissions(ctx context.Context, id int32) ApiSecurityRolePermissionsSetCollectionPermissionsRequest {
	return ApiSecurityRolePermissionsSetCollectionPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionResponse
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsSetCollectionPermissionsExecute(r ApiSecurityRolePermissionsSetCollectionPermissionsRequest) ([]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesCollectionPermissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityRolePermissionsApiService.SecurityRolePermissionsSetCollectionPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Security/Roles/{id}/Permissions/Collections"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.collectionPermissions == nil {
		return localVarReturnValue, nil, reportError("collectionPermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.collectionPermissions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolePermissionsSetContainerPermissionsRequest struct {
	ctx context.Context
	ApiService *SecurityRolePermissionsApiService
	id int32
	xKeyfactorRequestedWith *string
	containerPermissions *[]KeyfactorApiModelsSecurityRolesContainerPermissionRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolePermissionsSetContainerPermissionsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolePermissionsSetContainerPermissionsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Container permissions
func (r ApiSecurityRolePermissionsSetContainerPermissionsRequest) ContainerPermissions(containerPermissions []KeyfactorApiModelsSecurityRolesContainerPermissionRequest) ApiSecurityRolePermissionsSetContainerPermissionsRequest {
	r.containerPermissions = &containerPermissions
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolePermissionsSetContainerPermissionsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolePermissionsSetContainerPermissionsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolePermissionsSetContainerPermissionsRequest) Execute() ([]KeyfactorApiModelsSecurityRolesContainerPermissionResponse, *http.Response, error) {
	return r.ApiService.SecurityRolePermissionsSetContainerPermissionsExecute(r)
}

/*
SecurityRolePermissionsSetContainerPermissions Sets container permissions to the security role that matches the id.

### Valid Permissions ###
| Permission    | Requisite Permissions |
|---------------|-----------------------|
| Read          |                       |
| Schedule      | Read                  |
| Modify        | Read, Schedule        |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Security role identifier
 @return ApiSecurityRolePermissionsSetContainerPermissionsRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsSetContainerPermissions(ctx context.Context, id int32) ApiSecurityRolePermissionsSetContainerPermissionsRequest {
	return ApiSecurityRolePermissionsSetContainerPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsSecurityRolesContainerPermissionResponse
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsSetContainerPermissionsExecute(r ApiSecurityRolePermissionsSetContainerPermissionsRequest) ([]KeyfactorApiModelsSecurityRolesContainerPermissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsSecurityRolesContainerPermissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityRolePermissionsApiService.SecurityRolePermissionsSetContainerPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Security/Roles/{id}/Permissions/Containers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.containerPermissions == nil {
		return localVarReturnValue, nil, reportError("containerPermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.containerPermissions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolePermissionsSetGlobalPermissionsRequest struct {
	ctx context.Context
	ApiService *SecurityRolePermissionsApiService
	id int32
	xKeyfactorRequestedWith *string
	globalPermissions *[]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionRequest
	xKeyfactorApiVersion *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolePermissionsSetGlobalPermissionsRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolePermissionsSetGlobalPermissionsRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Global permissions
func (r ApiSecurityRolePermissionsSetGlobalPermissionsRequest) GlobalPermissions(globalPermissions []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionRequest) ApiSecurityRolePermissionsSetGlobalPermissionsRequest {
	r.globalPermissions = &globalPermissions
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolePermissionsSetGlobalPermissionsRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolePermissionsSetGlobalPermissionsRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolePermissionsSetGlobalPermissionsRequest) Execute() ([]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionResponse, *http.Response, error) {
	return r.ApiService.SecurityRolePermissionsSetGlobalPermissionsExecute(r)
}

/*
SecurityRolePermissionsSetGlobalPermissions Adds global permissions to the security role that matches the id.

### Valid Global Permissions ###
| Area                          | Permission        |
|-------------------------------|-------------------|
| AdminPortal                   | Read              |
| AgentAutoRegistration         | Read              |
| AgentAutoRegistration         | Modify            |
| AgentManagement               | Read              |
| AgentManagement               | Modify            |
| API                           | Read              |
| ApplicationSettings           | Read              |
| ApplicationSettings           | Modify            |
| Auditing                      | Read              |
| CertificateCollections        | Modify            |
| CertificateEnrollment         | EnrollPFX         |
| CertificateEnrollment         | EnrollCSR         |
| CertificateEnrollment         | CsrGeneration     |
| CertificateEnrollment         | PendingCsr        |
| CertificateMetadataTypes      | Read              |
| CertificateMetadataTypes      | Modify            |
| Certificates                  | Read              |
| Certificates                  | EditMetadata      |
| Certificates                  | Import            |
| Certificates                  | Recover           |
| Certificates                  | Revoke            |
| Certificates                  | Delete            |
| Certificates                  | ImportPrivateKey  |
| CertificateStoreManagement    | Read              |
| CertificateStoreManagement    | Schedule          |
| CertificateStoreManagement    | Modify            |
| Dashboard                     | Read              |
| Dashboard                     | RiskHeader        |
| EventHandlerRegistration      | Read              |
| EventHandlerRegistration      | Modify            |
| MacAutoEnrollManagement       | Read              |
| MacAutoEnrollManagement       | Modify            |
| Monitoring                    | Read              |
| Monitoring                    | Modify            |
| Monitoring                    | Test              |
| PkiManagement                 | Read              |
| PkiManagement                 | Modify            |
| PrivilegedAccessManagement    | Read              |
| PrivilegedAccessManagement    | Modify            |
| Reports                       | Read              |
| Reports                       | Modify            |
| SecuritySettings              | Read              |
| SecuritySettings              | Modify            |
| SSH                           | User              |
| SSH                           | ServerAdmin       |
| SSH                           | EnterpriseAdmin   |
| SslManagement                 | Read              |
| SslManagement                 | Modify            |
| SystemSettings                | Read              |
| SystemSettings                | Modify            |
| WorkflowDefinitions           | Read              |
| WorkflowDefinitions           | Modify            |
| WorkflowInstances             | ReadAll           |
| WorkflowInstances             | ReadAssignedToMe  |
| WorkflowInstances             | ReadMy            |
| WorkflowInstances             | Manage            |
| WorkflowManagement            | Read              |
| WorkflowManagement            | Modify            |
| WorkflowManagement            | Test              |
| WorkflowManagement            | Participate       |
| WorkflowManagement            | Manage            |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Security role identifier
 @return ApiSecurityRolePermissionsSetGlobalPermissionsRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsSetGlobalPermissions(ctx context.Context, id int32) ApiSecurityRolePermissionsSetGlobalPermissionsRequest {
	return ApiSecurityRolePermissionsSetGlobalPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionResponse
func (a *SecurityRolePermissionsApiService) SecurityRolePermissionsSetGlobalPermissionsExecute(r ApiSecurityRolePermissionsSetGlobalPermissionsRequest) ([]KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KeyfactorApiModelsSecurityRolesIdentitiesSecurityRolesGlobalPermissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityRolePermissionsApiService.SecurityRolePermissionsSetGlobalPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Security/Roles/{id}/Permissions/Global"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.globalPermissions == nil {
		return localVarReturnValue, nil, reportError("globalPermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.globalPermissions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
